{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#hydralette","title":"Hydralette","text":"<p>Create complex configurations in a simple, pythonic way!</p> <p> </p> <p>Documentation</p>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install hydralette\n# OR\npoetry add hydralette\n</code></pre>"},{"location":"#changelog","title":"Changelog","text":"<ul> <li>v0.2.4<ul> <li>bugfix: allow overriding fields with reference</li> </ul> </li> <li>v0.2.3<ul> <li>change version of <code>dill</code> dependency</li> </ul> </li> <li>v0.2.2<ul> <li>support mixing _fields, _groups and _from_signature</li> <li>support literal values as groups</li> <li>add boolean flags as <code>--flag</code> or <code>--no-flag</code></li> </ul> </li> <li>v0.2.1<ul> <li>fix yaml representation</li> <li>support setting value to None in automatic conversion</li> </ul> </li> <li>v0.2.0<ul> <li>complete re-design --&gt; breaking changes!</li> <li>easier creation of hierarchical configs</li> </ul> </li> <li>v0.1.5<ul> <li>Add yaml overrides</li> <li>Add end-to-end tests with pytest</li> </ul> </li> <li>v0.1.4<ul> <li>Add documentation at https://valeknappich.github.io/hydralette</li> </ul> </li> <li>v0.1.3<ul> <li>Add automatic generation of configs from signatures via <code>from_signature</code> and <code>config_from_signature</code></li> </ul> </li> <li>v0.1.2<ul> <li>Add support for <code>config groups</code>, <code>references</code>, <code>validation</code> and <code>type conversion</code></li> <li>Add CLI help pages</li> </ul> </li> </ul>"},{"location":"#features","title":"Features","text":""},{"location":"#basics","title":"Basics","text":"<p>Create a config using the <code>Config</code> class, passing the config fields as keyword arguments.</p> <pre><code>from hydralette import Config\ncfg = Config(a=1, b=2, c=\"abc\")\n</code></pre> <p><code>Config</code> objects can be create from and exported to <code>dict</code>s.</p> <pre><code>from hydralette import Config\ncfg = Config.from_dict({\"a\": 1, \"b\": 2, \"c\": \"abc\"})\nprint(cfg.to_dict())\n</code></pre> <p>Every hydralette <code>Config</code> be overriden via CLI:</p> <pre><code>from hydralette import Config, Field\ncfg = Config(\n    a=Field(default=1, help=\"Lorem ipsum\"),\n    b=Config(\n        c=Field(default=2, help=\"Lorem ipsum\")\n    )\n)\ncfg.apply([\"--help\"]) # or cfg.print_help()\n\n# prints:\n\n# Usage python script.py [OPTIONS]\n# --a 1                   Lorem ipsum\n# --b.c 1                 Lorem ipsum\n</code></pre> <p>After creation, you can override, resolve references, validate and check for missing required arguments.</p> <pre><code>cfg.override([\"--a\", \"1\"]) # overrides defaults to sys.argv[1:]\ncfg.resolve_references()\ncfg.validate()\ncfg.check_required_args()\n# OR\ncfg.apply([\"--a\", \"1\"]) # shorthand for the above\n</code></pre>"},{"location":"#groups","title":"Groups","text":"<p>Config groups can be very handy to make components interchangeable without requiring them to share a config.</p> <pre><code>from hydralette import Config, Field\ncfg = Config(\n    model=Config(\n        _groups={\n            \"_default\": \"rnn\",\n            \"rnn\": Config(\n                n_layers=2,\n                bidirectional=False\n            ),\n            \"transformer\": Config(\n                n_layers=16,\n                num_attention_heads=8\n            )\n        }\n    )\n)\ncfg.apply([\"--model\", \"transformer\"])\n</code></pre>"},{"location":"#from-signature-existing-config","title":"From signature / existing config","text":"<p>Often times, part of your configuration is already implemented somewhere else and duplicating this information creates a source of failure. Instead, you can automatically generate your hydralette <code>Config</code> based on an existing interface</p> <pre><code>def calc(a: int, b=2):\n    pass\n\nfrom hydralette import Config, Field\ncfg = Config(_from_signature=calc)\n# equivalent to\ncfg = Config(a=Field(type=int), b=Field(default=2, type=int))\n</code></pre>"},{"location":"#fields","title":"Fields","text":"<p>When you directly pass a value to <code>Config</code>s constructor, hydralette will create a <code>Field</code> under the hood. To use additional features, you can create it explicitly</p> <p><code>convert</code>: Specify how command-line overrides should be converted to the target type. If not explicitly specified, hydralette tries to use the field's <code>type</code> as conversion function (<code>type</code> is either explicitly specified or automatically derived from <code>default</code> / <code>default_factory</code>).</p> <pre><code>import json\nfrom hydralette import Config, Field\ncfg = Config(my_dict=Field(default={\"a\": 1, \"b\": {\"c\": 2}}, convert=json.loads))\ncfg.apply(['--my_dict', r'{\"a\": 2, \"b\": {\"c\": 3}}'])\n</code></pre> <p><code>validate</code>: Constrain what values are valid for your field. If the validity of a value depends on the rest of the config, use <code>_validate</code> in the <code>Config</code> constructor instead.</p> <pre><code>from hydralette import Config, Field\ncfg = Config(n=Field(default=1, validate=lambda n: n &gt; 0))\ncfg.apply(['--n', '-1'])\n# throws: ValidationError: Field validation failed for -1\ncfg = Config(_validate=lambda cfg: cfg.a &gt; cfg.b, a=1, b=2)\ncfg.apply() # or cfg.validate()\n# throws: ValidationError: Config validation failed for {'a': 1, 'b': 2}\n</code></pre> <p><code>reference</code> / <code>reference_root</code>: Refer to any other value in the config or root config </p> <p>[!NOTE] Hydralette will not automatically infer the type from the reference lambda. To get automatic conversion of CLI arguments, pass <code>type</code> or <code>convert</code> explicitly.</p> <pre><code>from hydralette import Config, Field\nfrom pathlib import Path\ncfg = Config(\n    dir=Path(\"outputs\"),\n    train=Config(\n        checkpoint_dir=Field(reference_root=lambda cfg: cfg.dir / \"checkpoints\", type=Path), # relative to current config\n        metrics_dir=Field(reference=lambda cfg: cfg.checkpoint_dir.parent / \"metrics\", type=Path) # relative to root config\n    )\n)\ncfg.resolve_references()\n</code></pre>"},{"location":"#backlog","title":"Backlog","text":"<ul> <li>[x] CLI</li> <li>[x] groups</li> <li>[x] from signatures</li> <li>[x] validation</li> <li>[x] conversion</li> <li>[x] references</li> <li>[x] yaml representation</li> <li>[x] pickle serialization</li> <li>[x] allow combining _groups, _fields and _from_signature</li> <li>[x] special support for boolean flags in CLI</li> </ul>"},{"location":"#dev-info","title":"Dev Info","text":"<p>Steps on new release:</p> <ol> <li>Run tests <code>pytest</code></li> <li>Edit docs</li> <li>Increment version in <code>pyproject.toml</code></li> <li>Add changelog to <code>README.md</code></li> <li>Push increment to GitHub</li> <li>Publish to PyPI <code>poetry publish --build</code></li> <li>Publish docs <code>mkdocs gh-deploy</code></li> <li>Create release and tag on GitHub</li> </ol>"},{"location":"API/","title":"API Reference","text":""},{"location":"API/#hydralette.Config","title":"<code>hydralette.Config</code>","text":"Source code in <code>hydralette/hydralette.py</code> <pre><code>class Config:\n    def __init__(\n        self,\n        _validate: Callable[[Any], Any] | UNSPECIFIED_TYPE = UNSPECIFIED,\n        _groups: dict[str, Union[\"Config\", Any]] | UNSPECIFIED_TYPE = UNSPECIFIED,\n        _from_signature: Callable | UNSPECIFIED_TYPE = UNSPECIFIED,\n        **_fields,\n    ):\n        self._validate = _validate\n        self._groups = _groups\n        self._current_group = UNSPECIFIED\n        self._from_signature = _from_signature\n        self._fields = {}\n\n        # 1. initialize fields from signature\n        if not isinstance(self._from_signature, UNSPECIFIED_TYPE):\n            self._fields = fields_from_signature(inspect.signature(self._from_signature))\n\n        # 2. set fields from kwargs (potentially overriding fields from signature)\n        if _fields:\n            self._fields = {**self._fields, **self._make_fields(_fields)}\n\n        # 3. validate groups and set _current_group to _default\n        if not isinstance(self._groups, UNSPECIFIED_TYPE):\n            if \"_default\" not in self._groups:\n                raise MisconfigurationError(\"'_default' must be in _groups dict\")\n            self._current_group = self._groups.pop(\"_default\")\n\n    def _make_fields(self, fields: dict[str, Any]) -&gt; dict[str, \"Config | Field\"]:\n        \"\"\"Create Field objects for fields that were passed as default value only.\"\"\"\n        for k, v in fields.items():\n            if not isinstance(v, Field) and not isinstance(v, Config):\n                fields[k] = Field(default=v)\n        return fields\n\n    def check_required_args(self, _path=\"\") -&gt; None:\n        \"\"\"Verify that all required arguments were set. Recursively searches config fields for UNSPECIFIED\"\"\"\n        for name, field in get_all_fields(self).items():\n            if isinstance(field, Field):\n                if isinstance(field.value, UNSPECIFIED_TYPE):\n                    raise MissingArgumentError(f\"Required argument '{_path}{name}' is missing\")\n\n            elif isinstance(field, Config):\n                field.check_required_args(_path=f\"{_path}{name}.\")\n\n    def apply(self, overrides: list[str] = sys.argv[1:]) -&gt; None:\n        \"\"\"Convenience method for common workflow after instantiation.\n        Overrides fields from CLI, resolves references, searches for unset required arguments and runs validation functions.\"\"\"\n        self.override(overrides)\n        self.resolve_references()\n        self.check_required_args()\n        self.validate()\n\n    def validate(self) -&gt; None:\n        \"\"\"Run validation functions recursively\"\"\"\n        # Run validation for this config\n        if not isinstance(self._validate, UNSPECIFIED_TYPE):\n            if not self._validate(self):\n                raise ValidationError(f\"Config validation failed for {self.to_dict()}\")\n\n        # Recursively validate sub-configs\n        for field in get_all_fields(self).values():\n            if isinstance(field, Config):\n                field.validate()\n\n            elif isinstance(field, Field) and not isinstance(field.validate, UNSPECIFIED_TYPE):\n                if not field.validate(field.value):\n                    raise ValidationError(f\"Field validation failed for {field.value}\")\n\n    def override(self, overrides: list[str] = sys.argv[1:]) -&gt; None:\n        \"\"\"Override values from commandline.\n        'overrides' argument should be of the same format as sys.argv[1:], e.g. [\"--a.b\", \"1\"].\n        Automatically prints help page if \"--help\" is in the overrides.\"\"\"\n\n        def extract_kv_pairs(overrides):\n            pairs = []\n            i = 0\n            while True:\n                if i &gt;= len(overrides):\n                    break\n                assert overrides[i].startswith(\"--\")\n                if i + 1 &lt; len(overrides) and not overrides[i + 1].startswith(\"--\"):\n                    pairs.append((overrides[i][2:], overrides[i + 1]))\n                    i += 1\n                else:\n                    pairs.append((overrides[i][2:],))\n                i += 1\n            return pairs\n\n        if \"--help\" in overrides:\n            self.print_help()\n            sys.exit(0)\n\n        for pair in extract_kv_pairs(overrides):\n            if len(pair) == 2:\n                key, value = pair\n            elif len(pair) == 1 and pair[0].startswith(BOOLEAN_NEGATED_FLAG_PREFIX):\n                key = pair[0][len(BOOLEAN_NEGATED_FLAG_PREFIX) :]\n                value = \"False\"\n            else:\n                key = pair[0]\n                value = \"True\"\n\n            # \".\" in key --&gt; delegate to subconfig\n            if \".\" in key:\n                first_dot_idx = key.index(\".\")\n                first_key, rest_key = key[:first_dot_idx], key[first_dot_idx + 1 :]\n\n                # subconfig is a regular field\n                if first_key in self._fields:\n                    sub_cfg = self._fields[first_key]\n\n                # subconfig is a group\n                elif (\n                    not isinstance(self._groups, UNSPECIFIED_TYPE)\n                    and isinstance(self._current_group, str)\n                    and first_key in self._groups[self._current_group]._fields\n                ):\n                    sub_cfg = self._groups[self._current_group]._fields[first_key]\n\n                # key neither in _fields not in _fields of current group\n                else:\n                    raise OverrideError(f\"Override key '{first_key}' not found\")\n\n                if not isinstance(sub_cfg, Config):\n                    raise OverrideError(f\"Field '{first_key}' is not a Config\")\n\n                sub_cfg.override([f\"--{rest_key}\", value])\n\n            # key does not have \".\" --&gt; override value here\n            else:\n                if key in self._fields:\n                    child = self._fields[key]\n\n                elif (\n                    not isinstance(self._groups, UNSPECIFIED_TYPE)\n                    and isinstance(self._current_group, str)\n                    and key in self._groups[self._current_group]._fields\n                ):\n                    child = self._groups[self._current_group]._fields[key]\n\n                else:\n                    raise OverrideError(f\"Override key '{key}' not found\")\n\n                # regular field override\n                if isinstance(child, Field):\n                    child.value = child.convert_value(value)\n                    child.was_overriden = True\n\n                # switch groups override\n                elif isinstance(child, Config):\n                    if isinstance(child._groups, UNSPECIFIED_TYPE):\n                        raise OverrideError(\"Can't override config unless it has groups\")\n                    elif value not in child._groups:\n                        raise OverrideError(f\"Group '{value}' does not exist\")\n                    child._current_group = value\n\n    def resolve_references(self, _root: \"Config | UNSPECIFIED_TYPE\" = UNSPECIFIED) -&gt; None:\n        \"\"\"Recursively run 'reference' and 'root_reference' functions\"\"\"\n        if isinstance(_root, UNSPECIFIED_TYPE):\n            _root = self\n\n        for field in get_all_fields(self).values():\n            if isinstance(field, Field) and not field.was_overriden and not isinstance(field.reference, UNSPECIFIED_TYPE):\n                field.value = field.reference(self)\n\n            elif isinstance(field, Field) and not field.was_overriden and not isinstance(field.reference_root, UNSPECIFIED_TYPE):\n                field.value = field.reference_root(_root)\n\n            elif isinstance(field, Config):\n                field.resolve_references(_root=_root)\n\n    def print_help(self, _path: str = \"\", _group_prefix: str = \"\", _root: bool = True) -&gt; None:\n        \"\"\"Print help page for CLI.\"\"\"\n        if _root:\n            print(f\"Usage python {sys.argv[0]} [OPTIONS]\")\n\n        field_fields = [(field_name, field) for field_name, field in self._fields.items() if isinstance(field, Field)]\n        config_fields = [(field_name, field) for field_name, field in self._fields.items() if isinstance(field, Config)]\n        groups = (\n            [(group_name, group) for group_name, group in self._groups.items()]\n            if not isinstance(self._groups, UNSPECIFIED_TYPE)\n            else []\n        )\n\n        print_space = True\n\n        if _group_prefix:\n            print(f\"\\n{_group_prefix}\")\n            print_space = False\n\n        for field_name, field in field_fields:\n            default = UNSPECIFIED\n            if not isinstance(field.default, UNSPECIFIED_TYPE):\n                default = field.default\n            elif not isinstance(field.default_factory, UNSPECIFIED_TYPE):\n                default = field.default_factory()\n            help_text = \"\"\n            if not isinstance(field.help, UNSPECIFIED_TYPE):\n                help_text = f\"\\t\\t\\t{field.help}\"\n\n            if print_space:\n                print()\n                print_space = False\n            print(f\"--{_path}{field_name} {default}{help_text}\")\n\n        for field_name, field in config_fields:\n            field.print_help(_path=_path + field_name + \".\", _root=False)\n\n        for group_name, group in groups:\n            group.print_help(_path, f\"if --{_path[:-1]} {group_name}\", _root=False)\n\n    @classmethod\n    def from_dict(cls, d: dict) -&gt; \"Config\":\n        \"\"\"Create Config from dict recursively.\n        Config(a=1, b=Config(c=2, d=4)) == Config.from_dict({\"a\": 1, \"b\": {\"c\": 2, \"d\": 4}})\"\"\"\n        cfg_dict = {k: v if not isinstance(v, dict) else Config.from_dict(v) for k, v in d.items()}\n        return Config(**cfg_dict)  # type: ignore\n\n    def to_dict(self) -&gt; dict:\n        \"\"\"Convert config to dict {field_name: field.value}.\n        Resulting dict does not include extra features like validation or reference lambdas, just field names and values.\"\"\"\n\n        def format_value(v):\n            if isinstance(v, Field):\n                return v.value\n\n            elif (  # if a group config has a literal value instead of a config, we return it directly\n                isinstance(v, Config)\n                and not v._fields\n                and not isinstance(v._groups, UNSPECIFIED_TYPE)\n                and isinstance(v._current_group, str)\n                and not isinstance(v._groups[v._current_group], Config)\n            ):\n                return v._groups[v._current_group]\n\n            elif isinstance(v, Config):\n                return v.to_dict()\n            else:\n                return v\n\n        return {k: format_value(v) for k, v in get_all_fields(self).items()}\n\n    def to_yaml(self) -&gt; str:\n        \"\"\"Convert config to YAML.\n        This is not intended as re-loadable serialization, but merely as a readable representation of the config!\n        To save and load your config later, use `.to_pickle` instead.\"\"\"\n\n        def normalize_values(d: dict):\n            for k, v in d.items():\n                if isinstance(v, dict):\n                    d[k] = normalize_values(v)\n                elif is_builtin(type(v)):\n                    d[k] = v\n                else:\n                    d[k] = repr(v)\n            return d\n\n        return yaml.dump(normalize_values(self.to_dict()), sort_keys=False).strip()\n\n    def to_pickle(self, path: str | Path) -&gt; None:\n        \"\"\"Pickle the config using dill.\"\"\"\n        with open(path, \"wb\") as fp:\n            dill.dump(self, fp, dill.HIGHEST_PROTOCOL)\n\n    @staticmethod\n    def from_pickle(path: str | Path) -&gt; \"Config\":\n        \"\"\"Load pickled config using dill\"\"\"\n        with open(path, \"rb\") as fp:\n            cfg = dill.load(fp, dill.HIGHEST_PROTOCOL)\n        return cfg\n\n    def __getstate__(self) -&gt; object:\n        return self.__dict__\n\n    def __setstate__(self, state) -&gt; None:\n        self.__dict__ = state\n\n    def __repr__(self) -&gt; str:\n        \"\"\"Use yaml formatting as readable representation of a config. Might change in the future.\"\"\"\n        return f\"Config({self.to_dict()})\"\n\n    def __getattr__(self, __name: str) -&gt; Any:\n        \"\"\"Allow direct member access to fields. Is only called if the name could not be found in the config object.\"\"\"\n        all_fields = get_all_fields(self)\n        if __name in all_fields:\n            v = all_fields[__name]\n            if isinstance(v, Field):\n                return v.value\n            elif isinstance(v, Config):\n                return v\n            else:\n                raise Exception(\"field values should only be Field's or Config's?\")\n\n        raise AttributeError(f\"{__name} not found. Fields: {list(self._fields.keys())}\")\n\n    def __setattr__(self, __name: str, __value: Any) -&gt; None:\n        \"\"\"Sets the value for a field.\n        This automatically triggers the validation on the config and the field.\"\"\"\n        if __name in {\n            \"_validate\",\n            \"_groups\",\n            \"_from_signature\",\n            \"_current_group\",\n            \"_fields\",\n        } or __name.startswith(\"__\"):\n            super().__setattr__(__name, __value)\n            return\n\n        all_fields = get_all_fields(self)\n\n        if __name in all_fields:\n            orig_value = all_fields[__name].value\n            all_fields[__name].value = __value\n            if not isinstance(self._validate, UNSPECIFIED_TYPE):\n                if not self._validate(self):\n                    msg = f\"Config validation failed for {self.to_dict()}\"\n                    all_fields[__name].value = orig_value\n                    raise ValidationError(msg)\n        else:\n            raise AttributeError(f\"{__name} not found\")\n\n    def __eq__(self, other):\n        \"\"\"Check equality using to_dict\"\"\"\n        if not isinstance(other, Config):\n            return False\n\n        return self.to_dict() == other.to_dict()\n</code></pre>"},{"location":"API/#hydralette.Config.__init__","title":"<code>__init__(_validate=UNSPECIFIED, _groups=UNSPECIFIED, _from_signature=UNSPECIFIED, **_fields)</code>","text":"Source code in <code>hydralette/hydralette.py</code> <pre><code>def __init__(\n    self,\n    _validate: Callable[[Any], Any] | UNSPECIFIED_TYPE = UNSPECIFIED,\n    _groups: dict[str, Union[\"Config\", Any]] | UNSPECIFIED_TYPE = UNSPECIFIED,\n    _from_signature: Callable | UNSPECIFIED_TYPE = UNSPECIFIED,\n    **_fields,\n):\n    self._validate = _validate\n    self._groups = _groups\n    self._current_group = UNSPECIFIED\n    self._from_signature = _from_signature\n    self._fields = {}\n\n    # 1. initialize fields from signature\n    if not isinstance(self._from_signature, UNSPECIFIED_TYPE):\n        self._fields = fields_from_signature(inspect.signature(self._from_signature))\n\n    # 2. set fields from kwargs (potentially overriding fields from signature)\n    if _fields:\n        self._fields = {**self._fields, **self._make_fields(_fields)}\n\n    # 3. validate groups and set _current_group to _default\n    if not isinstance(self._groups, UNSPECIFIED_TYPE):\n        if \"_default\" not in self._groups:\n            raise MisconfigurationError(\"'_default' must be in _groups dict\")\n        self._current_group = self._groups.pop(\"_default\")\n</code></pre>"},{"location":"API/#hydralette.Config.apply","title":"<code>apply(overrides=sys.argv[1:])</code>","text":"<p>Convenience method for common workflow after instantiation. Overrides fields from CLI, resolves references, searches for unset required arguments and runs validation functions.</p> Source code in <code>hydralette/hydralette.py</code> <pre><code>def apply(self, overrides: list[str] = sys.argv[1:]) -&gt; None:\n    \"\"\"Convenience method for common workflow after instantiation.\n    Overrides fields from CLI, resolves references, searches for unset required arguments and runs validation functions.\"\"\"\n    self.override(overrides)\n    self.resolve_references()\n    self.check_required_args()\n    self.validate()\n</code></pre>"},{"location":"API/#hydralette.Config.override","title":"<code>override(overrides=sys.argv[1:])</code>","text":"<p>Override values from commandline. 'overrides' argument should be of the same format as sys.argv[1:], e.g. [\"--a.b\", \"1\"]. Automatically prints help page if \"--help\" is in the overrides.</p> Source code in <code>hydralette/hydralette.py</code> <pre><code>def override(self, overrides: list[str] = sys.argv[1:]) -&gt; None:\n    \"\"\"Override values from commandline.\n    'overrides' argument should be of the same format as sys.argv[1:], e.g. [\"--a.b\", \"1\"].\n    Automatically prints help page if \"--help\" is in the overrides.\"\"\"\n\n    def extract_kv_pairs(overrides):\n        pairs = []\n        i = 0\n        while True:\n            if i &gt;= len(overrides):\n                break\n            assert overrides[i].startswith(\"--\")\n            if i + 1 &lt; len(overrides) and not overrides[i + 1].startswith(\"--\"):\n                pairs.append((overrides[i][2:], overrides[i + 1]))\n                i += 1\n            else:\n                pairs.append((overrides[i][2:],))\n            i += 1\n        return pairs\n\n    if \"--help\" in overrides:\n        self.print_help()\n        sys.exit(0)\n\n    for pair in extract_kv_pairs(overrides):\n        if len(pair) == 2:\n            key, value = pair\n        elif len(pair) == 1 and pair[0].startswith(BOOLEAN_NEGATED_FLAG_PREFIX):\n            key = pair[0][len(BOOLEAN_NEGATED_FLAG_PREFIX) :]\n            value = \"False\"\n        else:\n            key = pair[0]\n            value = \"True\"\n\n        # \".\" in key --&gt; delegate to subconfig\n        if \".\" in key:\n            first_dot_idx = key.index(\".\")\n            first_key, rest_key = key[:first_dot_idx], key[first_dot_idx + 1 :]\n\n            # subconfig is a regular field\n            if first_key in self._fields:\n                sub_cfg = self._fields[first_key]\n\n            # subconfig is a group\n            elif (\n                not isinstance(self._groups, UNSPECIFIED_TYPE)\n                and isinstance(self._current_group, str)\n                and first_key in self._groups[self._current_group]._fields\n            ):\n                sub_cfg = self._groups[self._current_group]._fields[first_key]\n\n            # key neither in _fields not in _fields of current group\n            else:\n                raise OverrideError(f\"Override key '{first_key}' not found\")\n\n            if not isinstance(sub_cfg, Config):\n                raise OverrideError(f\"Field '{first_key}' is not a Config\")\n\n            sub_cfg.override([f\"--{rest_key}\", value])\n\n        # key does not have \".\" --&gt; override value here\n        else:\n            if key in self._fields:\n                child = self._fields[key]\n\n            elif (\n                not isinstance(self._groups, UNSPECIFIED_TYPE)\n                and isinstance(self._current_group, str)\n                and key in self._groups[self._current_group]._fields\n            ):\n                child = self._groups[self._current_group]._fields[key]\n\n            else:\n                raise OverrideError(f\"Override key '{key}' not found\")\n\n            # regular field override\n            if isinstance(child, Field):\n                child.value = child.convert_value(value)\n                child.was_overriden = True\n\n            # switch groups override\n            elif isinstance(child, Config):\n                if isinstance(child._groups, UNSPECIFIED_TYPE):\n                    raise OverrideError(\"Can't override config unless it has groups\")\n                elif value not in child._groups:\n                    raise OverrideError(f\"Group '{value}' does not exist\")\n                child._current_group = value\n</code></pre>"},{"location":"API/#hydralette.Config.check_required_args","title":"<code>check_required_args(_path='')</code>","text":"<p>Verify that all required arguments were set. Recursively searches config fields for UNSPECIFIED</p> Source code in <code>hydralette/hydralette.py</code> <pre><code>def check_required_args(self, _path=\"\") -&gt; None:\n    \"\"\"Verify that all required arguments were set. Recursively searches config fields for UNSPECIFIED\"\"\"\n    for name, field in get_all_fields(self).items():\n        if isinstance(field, Field):\n            if isinstance(field.value, UNSPECIFIED_TYPE):\n                raise MissingArgumentError(f\"Required argument '{_path}{name}' is missing\")\n\n        elif isinstance(field, Config):\n            field.check_required_args(_path=f\"{_path}{name}.\")\n</code></pre>"},{"location":"API/#hydralette.Config.validate","title":"<code>validate()</code>","text":"<p>Run validation functions recursively</p> Source code in <code>hydralette/hydralette.py</code> <pre><code>def validate(self) -&gt; None:\n    \"\"\"Run validation functions recursively\"\"\"\n    # Run validation for this config\n    if not isinstance(self._validate, UNSPECIFIED_TYPE):\n        if not self._validate(self):\n            raise ValidationError(f\"Config validation failed for {self.to_dict()}\")\n\n    # Recursively validate sub-configs\n    for field in get_all_fields(self).values():\n        if isinstance(field, Config):\n            field.validate()\n\n        elif isinstance(field, Field) and not isinstance(field.validate, UNSPECIFIED_TYPE):\n            if not field.validate(field.value):\n                raise ValidationError(f\"Field validation failed for {field.value}\")\n</code></pre>"},{"location":"API/#hydralette.Config.resolve_references","title":"<code>resolve_references(_root=UNSPECIFIED)</code>","text":"<p>Recursively run 'reference' and 'root_reference' functions</p> Source code in <code>hydralette/hydralette.py</code> <pre><code>def resolve_references(self, _root: \"Config | UNSPECIFIED_TYPE\" = UNSPECIFIED) -&gt; None:\n    \"\"\"Recursively run 'reference' and 'root_reference' functions\"\"\"\n    if isinstance(_root, UNSPECIFIED_TYPE):\n        _root = self\n\n    for field in get_all_fields(self).values():\n        if isinstance(field, Field) and not field.was_overriden and not isinstance(field.reference, UNSPECIFIED_TYPE):\n            field.value = field.reference(self)\n\n        elif isinstance(field, Field) and not field.was_overriden and not isinstance(field.reference_root, UNSPECIFIED_TYPE):\n            field.value = field.reference_root(_root)\n\n        elif isinstance(field, Config):\n            field.resolve_references(_root=_root)\n</code></pre>"},{"location":"API/#hydralette.Config.print_help","title":"<code>print_help(_path='', _group_prefix='', _root=True)</code>","text":"<p>Print help page for CLI.</p> Source code in <code>hydralette/hydralette.py</code> <pre><code>def print_help(self, _path: str = \"\", _group_prefix: str = \"\", _root: bool = True) -&gt; None:\n    \"\"\"Print help page for CLI.\"\"\"\n    if _root:\n        print(f\"Usage python {sys.argv[0]} [OPTIONS]\")\n\n    field_fields = [(field_name, field) for field_name, field in self._fields.items() if isinstance(field, Field)]\n    config_fields = [(field_name, field) for field_name, field in self._fields.items() if isinstance(field, Config)]\n    groups = (\n        [(group_name, group) for group_name, group in self._groups.items()]\n        if not isinstance(self._groups, UNSPECIFIED_TYPE)\n        else []\n    )\n\n    print_space = True\n\n    if _group_prefix:\n        print(f\"\\n{_group_prefix}\")\n        print_space = False\n\n    for field_name, field in field_fields:\n        default = UNSPECIFIED\n        if not isinstance(field.default, UNSPECIFIED_TYPE):\n            default = field.default\n        elif not isinstance(field.default_factory, UNSPECIFIED_TYPE):\n            default = field.default_factory()\n        help_text = \"\"\n        if not isinstance(field.help, UNSPECIFIED_TYPE):\n            help_text = f\"\\t\\t\\t{field.help}\"\n\n        if print_space:\n            print()\n            print_space = False\n        print(f\"--{_path}{field_name} {default}{help_text}\")\n\n    for field_name, field in config_fields:\n        field.print_help(_path=_path + field_name + \".\", _root=False)\n\n    for group_name, group in groups:\n        group.print_help(_path, f\"if --{_path[:-1]} {group_name}\", _root=False)\n</code></pre>"},{"location":"API/#hydralette.Config.from_dict","title":"<code>from_dict(d)</code>  <code>classmethod</code>","text":"<p>Create Config from dict recursively. Config(a=1, b=Config(c=2, d=4)) == Config.from_dict({\"a\": 1, \"b\": {\"c\": 2, \"d\": 4}})</p> Source code in <code>hydralette/hydralette.py</code> <pre><code>@classmethod\ndef from_dict(cls, d: dict) -&gt; \"Config\":\n    \"\"\"Create Config from dict recursively.\n    Config(a=1, b=Config(c=2, d=4)) == Config.from_dict({\"a\": 1, \"b\": {\"c\": 2, \"d\": 4}})\"\"\"\n    cfg_dict = {k: v if not isinstance(v, dict) else Config.from_dict(v) for k, v in d.items()}\n    return Config(**cfg_dict)  # type: ignore\n</code></pre>"},{"location":"API/#hydralette.Config.to_dict","title":"<code>to_dict()</code>","text":"<p>Convert config to dict {field_name: field.value}. Resulting dict does not include extra features like validation or reference lambdas, just field names and values.</p> Source code in <code>hydralette/hydralette.py</code> <pre><code>def to_dict(self) -&gt; dict:\n    \"\"\"Convert config to dict {field_name: field.value}.\n    Resulting dict does not include extra features like validation or reference lambdas, just field names and values.\"\"\"\n\n    def format_value(v):\n        if isinstance(v, Field):\n            return v.value\n\n        elif (  # if a group config has a literal value instead of a config, we return it directly\n            isinstance(v, Config)\n            and not v._fields\n            and not isinstance(v._groups, UNSPECIFIED_TYPE)\n            and isinstance(v._current_group, str)\n            and not isinstance(v._groups[v._current_group], Config)\n        ):\n            return v._groups[v._current_group]\n\n        elif isinstance(v, Config):\n            return v.to_dict()\n        else:\n            return v\n\n    return {k: format_value(v) for k, v in get_all_fields(self).items()}\n</code></pre>"},{"location":"API/#hydralette.Config.to_yaml","title":"<code>to_yaml()</code>","text":"<p>Convert config to YAML. This is not intended as re-loadable serialization, but merely as a readable representation of the config! To save and load your config later, use <code>.to_pickle</code> instead.</p> Source code in <code>hydralette/hydralette.py</code> <pre><code>def to_yaml(self) -&gt; str:\n    \"\"\"Convert config to YAML.\n    This is not intended as re-loadable serialization, but merely as a readable representation of the config!\n    To save and load your config later, use `.to_pickle` instead.\"\"\"\n\n    def normalize_values(d: dict):\n        for k, v in d.items():\n            if isinstance(v, dict):\n                d[k] = normalize_values(v)\n            elif is_builtin(type(v)):\n                d[k] = v\n            else:\n                d[k] = repr(v)\n        return d\n\n    return yaml.dump(normalize_values(self.to_dict()), sort_keys=False).strip()\n</code></pre>"},{"location":"API/#hydralette.Config.to_pickle","title":"<code>to_pickle(path)</code>","text":"<p>Pickle the config using dill.</p> Source code in <code>hydralette/hydralette.py</code> <pre><code>def to_pickle(self, path: str | Path) -&gt; None:\n    \"\"\"Pickle the config using dill.\"\"\"\n    with open(path, \"wb\") as fp:\n        dill.dump(self, fp, dill.HIGHEST_PROTOCOL)\n</code></pre>"},{"location":"API/#hydralette.Config.from_pickle","title":"<code>from_pickle(path)</code>  <code>staticmethod</code>","text":"<p>Load pickled config using dill</p> Source code in <code>hydralette/hydralette.py</code> <pre><code>@staticmethod\ndef from_pickle(path: str | Path) -&gt; \"Config\":\n    \"\"\"Load pickled config using dill\"\"\"\n    with open(path, \"rb\") as fp:\n        cfg = dill.load(fp, dill.HIGHEST_PROTOCOL)\n    return cfg\n</code></pre>"},{"location":"API/#hydralette.Field","title":"<code>hydralette.Field</code>","text":"Source code in <code>hydralette/hydralette.py</code> <pre><code>class Field:\n\n    def __init__(\n        self,\n        type: type | UNSPECIFIED_TYPE = UNSPECIFIED,\n        default: Any | UNSPECIFIED_TYPE = UNSPECIFIED,\n        default_factory: Callable[[], Any] | UNSPECIFIED_TYPE = UNSPECIFIED,\n        convert: Callable[[str], Any] | UNSPECIFIED_TYPE = UNSPECIFIED,\n        validate: Callable[[Any], bool] | UNSPECIFIED_TYPE = UNSPECIFIED,\n        reference: Callable[[Config], Any] | UNSPECIFIED_TYPE = UNSPECIFIED,\n        reference_root: Callable[[Config], Any] | UNSPECIFIED_TYPE = UNSPECIFIED,\n        help: str | UNSPECIFIED_TYPE = UNSPECIFIED,\n    ):\n        self.type = type\n        self.default = default\n        self.default_factory = default_factory\n        self.convert = convert\n        self.validate = validate\n        self.help = help\n        self.reference = reference\n        self.reference_root = reference_root\n        self.was_overriden = False\n\n        self._value = None\n        _value = UNSPECIFIED\n        if not isinstance(default, UNSPECIFIED_TYPE):\n            _value = default\n        elif not isinstance(default_factory, UNSPECIFIED_TYPE):\n            _value = default_factory()\n        self.value = _value\n\n        if isinstance(self.type, UNSPECIFIED_TYPE) and not isinstance(self.value, UNSPECIFIED_TYPE):\n            self.type = builtins.type(self.value)\n\n    @classmethod\n    def from_signature_paramter(cls, parameter: inspect.Parameter) -&gt; \"Field\":\n        kwargs = {}\n\n        if parameter.annotation != inspect._empty:\n            kwargs[\"type\"] = parameter.annotation\n\n        if parameter.default != inspect._empty:\n            kwargs[\"default\"] = parameter.default\n        elif parameter.kind == inspect.Parameter.VAR_KEYWORD:\n            kwargs[\"default\"] = {}\n        elif parameter.kind == inspect.Parameter.VAR_POSITIONAL:\n            kwargs[\"default\"] = []\n\n        if \"default\" in kwargs and \"type\" not in kwargs:\n            kwargs[\"type\"] = type(kwargs[\"default\"])\n\n        return Field(**kwargs)\n\n    def convert_value(self, value: Any) -&gt; Any:\n        if not isinstance(self.convert, UNSPECIFIED_TYPE):\n            value = self.convert(value)\n\n        elif value in SPECIAL_VALUES:\n            value = SPECIAL_VALUES[value]\n\n        elif not isinstance(self.type, UNSPECIFIED_TYPE) and callable(self.type):\n            try:\n                value = self.type(value)\n            except:  # noqa\n                pass\n\n        return value\n\n    @property\n    def value(self):\n        return self._value\n\n    @value.setter\n    def value(self, v):\n        self._value = v\n\n    def __repr__(self):\n        return repr(self.value)\n</code></pre>"},{"location":"API/#hydralette.Field.__init__","title":"<code>__init__(type=UNSPECIFIED, default=UNSPECIFIED, default_factory=UNSPECIFIED, convert=UNSPECIFIED, validate=UNSPECIFIED, reference=UNSPECIFIED, reference_root=UNSPECIFIED, help=UNSPECIFIED)</code>","text":"Source code in <code>hydralette/hydralette.py</code> <pre><code>def __init__(\n    self,\n    type: type | UNSPECIFIED_TYPE = UNSPECIFIED,\n    default: Any | UNSPECIFIED_TYPE = UNSPECIFIED,\n    default_factory: Callable[[], Any] | UNSPECIFIED_TYPE = UNSPECIFIED,\n    convert: Callable[[str], Any] | UNSPECIFIED_TYPE = UNSPECIFIED,\n    validate: Callable[[Any], bool] | UNSPECIFIED_TYPE = UNSPECIFIED,\n    reference: Callable[[Config], Any] | UNSPECIFIED_TYPE = UNSPECIFIED,\n    reference_root: Callable[[Config], Any] | UNSPECIFIED_TYPE = UNSPECIFIED,\n    help: str | UNSPECIFIED_TYPE = UNSPECIFIED,\n):\n    self.type = type\n    self.default = default\n    self.default_factory = default_factory\n    self.convert = convert\n    self.validate = validate\n    self.help = help\n    self.reference = reference\n    self.reference_root = reference_root\n    self.was_overriden = False\n\n    self._value = None\n    _value = UNSPECIFIED\n    if not isinstance(default, UNSPECIFIED_TYPE):\n        _value = default\n    elif not isinstance(default_factory, UNSPECIFIED_TYPE):\n        _value = default_factory()\n    self.value = _value\n\n    if isinstance(self.type, UNSPECIFIED_TYPE) and not isinstance(self.value, UNSPECIFIED_TYPE):\n        self.type = builtins.type(self.value)\n</code></pre>"},{"location":"API/#hydralette.Field.from_signature_paramter","title":"<code>from_signature_paramter(parameter)</code>  <code>classmethod</code>","text":"Source code in <code>hydralette/hydralette.py</code> <pre><code>@classmethod\ndef from_signature_paramter(cls, parameter: inspect.Parameter) -&gt; \"Field\":\n    kwargs = {}\n\n    if parameter.annotation != inspect._empty:\n        kwargs[\"type\"] = parameter.annotation\n\n    if parameter.default != inspect._empty:\n        kwargs[\"default\"] = parameter.default\n    elif parameter.kind == inspect.Parameter.VAR_KEYWORD:\n        kwargs[\"default\"] = {}\n    elif parameter.kind == inspect.Parameter.VAR_POSITIONAL:\n        kwargs[\"default\"] = []\n\n    if \"default\" in kwargs and \"type\" not in kwargs:\n        kwargs[\"type\"] = type(kwargs[\"default\"])\n\n    return Field(**kwargs)\n</code></pre>"}]}