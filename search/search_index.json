{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#hydralette","title":"Hydralette","text":"<p>Create complex configurations in a simple, pythonic way!</p> <p> </p> <p>Documentation</p>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install hydralette\n# OR\npoetry add hydralette\n</code></pre>"},{"location":"#changelog","title":"Changelog","text":"<ul> <li>v0.2.0<ul> <li>complete re-design --&gt; breaking changes!</li> <li>easier creation of hierarchical configs</li> </ul> </li> <li>v0.1.5<ul> <li>Add yaml overrides</li> <li>Add end-to-end tests with pytest</li> </ul> </li> <li>v0.1.4<ul> <li>Add documentation at https://valeknappich.github.io/hydralette</li> </ul> </li> <li>v0.1.3<ul> <li>Add automatic generation of configs from signatures via <code>from_signature</code> and <code>config_from_signature</code></li> </ul> </li> <li>v0.1.2<ul> <li>Add support for <code>config groups</code>, <code>references</code>, <code>validation</code> and <code>type conversion</code></li> <li>Add CLI help pages</li> </ul> </li> </ul>"},{"location":"#features","title":"Features","text":""},{"location":"#basics","title":"Basics","text":"<p>Create a config using the <code>Config</code> class, passing the config fields as keyword arguments.</p> <pre><code>from hydralette import Config\ncfg = Config(a=1, b=2, c=\"abc\")\n</code></pre> <p><code>Config</code> objects can be create from and exported to <code>dict</code>s.</p> <pre><code>from hydralette import Config\ncfg = Config.from_dict({\"a\": 1, \"b\": 2, \"c\": \"abc\"})\nprint(cfg.to_dict())\n</code></pre> <p>Every hydralette <code>Config</code> be overriden via CLI:</p> <pre><code>from hydralette import Config, Field\ncfg = Config(\n    a=Field(default=1, help=\"Lorem ipsum\"),\n    b=Config(\n        c=Field(default=2, help=\"Lorem ipsum\")\n    )\n)\ncfg.apply([\"--help\"]) # or cfg.print_help()\n\n# prints:\n\n# Usage python script.py [OPTIONS]\n# --a 1                   Lorem ipsum\n# --b.c 1                 Lorem ipsum\n</code></pre> <p>After creation, you can override, resolve references, validate and check for missing required arguments.</p> <pre><code>cfg.override([\"--a\", \"1\"]) # overrides defaults to sys.argv[1:]\ncfg.resolve_references()\ncfg.validate()\ncfg.check_required_args()\n# OR\ncfg.apply([\"--a\", \"1\"]) # shorthand for the above\n</code></pre>"},{"location":"#groups","title":"Groups","text":"<p>Config groups can be very handy to make components interchangeable without requiring them to share a config.</p> <pre><code>from hydralette import Config, Field\ncfg = Config(\n    model=Config(\n        _groups={\n            \"_default\": \"rnn\",\n            \"rnn\": Config(\n                n_layers=2,\n                bidirectional=False\n            ),\n            \"transformer\": Config(\n                n_layers=16,\n                num_attention_heads=8\n            )\n        }\n    )\n)\ncfg.apply([\"--model\", \"transformer\"])\n</code></pre>"},{"location":"#from-signature-existing-config","title":"From signature / existing config","text":"<p>Often times, part of your configuration is already implemented somewhere else and duplicating this information creates a source of failure. Instead, you can automatically generate your hydralette <code>Config</code> based on an existing interface</p> <pre><code>def calc(a: int, b=2):\n    pass\n\nfrom hydralette import Config, Field\ncfg = Config(_from_signature=calc)\n# equivalent to\ncfg = Config(a=Field(type=int), b=Field(default=2, type=int))\n</code></pre>"},{"location":"#fields","title":"Fields","text":"<p>When you directly pass a value to <code>Config</code>s constructor, hydralette will create a <code>Field</code> under the hood. To use additional features, you can create it explicitly</p> <p><code>convert</code>: Specify how command-line overrides should be converted to the target type. If not explicitly specified, hydralette tries to use the field's <code>type</code> as conversion function (<code>type</code> is either explicitly specified or automatically derived from <code>default</code> / <code>default_factory</code>).</p> <pre><code>import json\nfrom hydralette import Config, Field\ncfg = Config(my_dict=Field(default={\"a\": 1, \"b\": {\"c\": 2}}, convert=json.loads))\ncfg.apply(['--my_dict', r'{\"a\": 2, \"b\": {\"c\": 3}}'])\n</code></pre> <p><code>validate</code>: Constrain what values are valid for your field. If the validity of a value depends on the rest of the config, use <code>_validate</code> in the <code>Config</code> constructor instead.</p> <pre><code>from hydralette import Config, Field\ncfg = Config(n=Field(default=1, validate=lambda n: n &gt; 0))\ncfg.apply(['--n', '-1'])\n# throws: ValidationError: Field validation failed for -1\ncfg = Config(_validate=lambda cfg: cfg.a &gt; cfg.b, a=1, b=2)\ncfg.apply() # or cfg.validate()\n# throws: ValidationError: Config validation failed for {'a': 1, 'b': 2}\n</code></pre> <p><code>reference</code> / <code>reference_root</code>: Refer to any other value in the config</p> <pre><code>from hydralette import Config, Field\nfrom pathlib import Path\ncfg = Config(\n    dir=Path(\"outputs\"),\n    train=Config(\n        checkpoint_dir=Field(reference_root=lambda cfg: cfg.dir / \"checkpoints\"), # relative to current config\n        metrics_dir=Field(reference=lambda cfg: cfg.checkpoint_dir.parent / \"metrics\") # relative to root config\n    )\n)\ncfg.resolve_references()\n</code></pre>"},{"location":"#backlog","title":"Backlog","text":"<ul> <li>[x] CLI</li> <li>[x] groups</li> <li>[x] from signatures</li> <li>[x] validation</li> <li>[x] conversion</li> <li>[x] references</li> <li>[ ] allow combining _groups with _fields</li> <li>[ ] dict overrides</li> <li>[ ] special support for boolean flags in CLI</li> </ul>"},{"location":"#dev-info","title":"Dev Info","text":"<pre><code># Run Tests\npytest\n# Publish docs\nmkdocs gh-deploy\n</code></pre>"},{"location":"API/","title":"API Reference","text":""},{"location":"API/#hydralette.Config","title":"<code>hydralette.Config</code>","text":"Source code in <code>hydralette/hydralette.py</code> <pre><code>class Config:\n    def __init__(\n        self,\n        _validate: Callable[[Any], Any] | UNSPECIFIED_TYPE = UNSPECIFIED,\n        _groups: dict[str, Union[\"Config\", Any]] | UNSPECIFIED_TYPE = UNSPECIFIED,\n        _from_signature: Callable | UNSPECIFIED_TYPE = UNSPECIFIED,\n        **_fields,\n    ):\n        self._validate = _validate\n        self._groups = _groups\n        self._from_signature = _from_signature\n        self._fields = self._make_fields(_fields)\n\n        n_methods = sum(\n            (\n                not isinstance(self._groups, UNSPECIFIED_TYPE),\n                not isinstance(self._from_signature, UNSPECIFIED_TYPE),\n                len(self._fields) &gt; 0,\n            )\n        )\n        if n_methods &gt; 1:\n            raise MisconfigurationError(\"Can only specify one of (_groups, _from_signature, fields)\")\n\n        self._current_group = UNSPECIFIED\n        if not isinstance(self._groups, UNSPECIFIED_TYPE):\n            if \"_default\" not in self._groups:\n                raise MisconfigurationError(\"'_default' must be in _groups dict\")\n            self._current_group = self._groups.pop(\"_default\")\n            for key, group in self._groups.items():\n                if not isinstance(group, Config):\n                    raise MisconfigurationError(f\"group value for '{key}'must be a Config\")\n\n        if not isinstance(self._from_signature, UNSPECIFIED_TYPE):\n            self._fields = fields_from_signature(inspect.signature(self._from_signature))\n\n    def _make_fields(self, fields: dict[str, Any]) -&gt; dict[str, \"Config | Field\"]:\n        for k, v in fields.items():\n            if not isinstance(v, Field) and not isinstance(v, Config):\n                fields[k] = Field(default=v)\n        return fields\n\n    def check_required_args(self, _path=\"\") -&gt; None:\n        for name, field in self._fields.items():\n            if isinstance(field, Field):\n                if isinstance(field.value, UNSPECIFIED_TYPE):\n                    raise MissingArgumentError(f\"Required argument '{_path}{name}' is missing\")\n                if not isinstance(field.validate, UNSPECIFIED_TYPE) and not field.validate():  # type: ignore\n                    raise ValidationError(f\"Field validation failed on '{_path}.{name}' for {field.value}\")\n\n            elif isinstance(field, Config):\n                field.check_required_args(_path=f\"{_path}{name}.\")\n\n    def apply(self, overrides: list[str] | dict = sys.argv[1:]) -&gt; None:\n        self.override(overrides)\n        self.resolve_references()\n        self.validate()\n        self.check_required_args()\n\n    def validate(self, _path=\"\") -&gt; None:\n        if not isinstance(self._validate, UNSPECIFIED_TYPE):\n            if not self._validate(self):\n                raise ValidationError(f\"Config validation failed for {self.to_dict()}\")\n\n        for name, field in self._fields.items():\n            if isinstance(field, Config):\n                field.check_required_args(_path=f\"{_path}{name}.\")\n\n    def override(self, overrides: list[str] | dict = sys.argv[1:]) -&gt; None:\n        if isinstance(overrides, list):\n            if \"--help\" in overrides:\n                self.print_help()\n                sys.exit(0)\n\n            for i in range(0, len(overrides), 2):\n                key = overrides[i][2:]\n                value = overrides[i + 1]\n\n                if \".\" in key:\n                    first_key = key.split(\".\")[0]\n                    rest = \".\".join(key.split(\".\")[1:])\n\n                    cfg = self if isinstance(self._groups, UNSPECIFIED_TYPE) else self._groups[self._current_group]  # type: ignore\n                    if first_key not in cfg._fields:\n                        raise OverrideError(f\"Override key '{first_key}' not found\")\n                    sub_cfg = cfg._fields[first_key]\n                    if not isinstance(sub_cfg, Config):\n                        raise OverrideError(f\"Field '{first_key}' is not a Config\")\n                    sub_cfg.override([f\"--{rest}\", value])\n\n                else:\n                    if isinstance(self._groups, UNSPECIFIED_TYPE):\n                        if key not in self._fields:\n                            raise OverrideError(f\"Override key {key} not found\")\n\n                        child = self._fields[key]\n                        if isinstance(child, Field):\n                            child.value = child.convert_value(value)\n\n                        elif isinstance(child, Config):\n                            if isinstance(child._groups, UNSPECIFIED_TYPE):\n                                raise OverrideError(\"Can't override config unless it has groups\")\n                            elif value not in child._groups:\n                                raise OverrideError(f\"Group '{value}' does not exist\")\n                            child._current_group = value\n                    else:\n                        fields = self._groups[self._current_group]._fields  # type: ignore\n                        if key not in fields:\n                            raise OverrideError(f\"Field '{key}' not found\")\n                        child = fields[key]\n                        if not isinstance(child, Field):\n                            raise OverrideError(\"Can't override config unless it has groups\")\n                        child.value = child.convert_value(value)\n\n        elif isinstance(overrides, Mapping):\n            # def flatten_dict(nested_dict, prefix='--'):\n            #     flattened = []\n            #     for key, value in nested_dict.items():\n            #         if isinstance(value, Mapping):\n            #             flattened.extend(flatten_dict(value, prefix + key + '.'))\n            #         else:\n            #             flattened.append(f'{prefix}{key} {value}')\n            #     return flattened\n\n            # self.override(flatten_dict(overrides))\n\n            # converting to string is problematic because values are converted to string --&gt; need to re-implement recursion for mappings\n            raise NotImplementedError(\"Overrides from mapping not supported yet\")\n\n    def resolve_references(self, _root: \"Config | UNSPECIFIED_TYPE\" = UNSPECIFIED) -&gt; None:\n        if isinstance(_root, UNSPECIFIED_TYPE):\n            _root = self\n\n        if isinstance(self._groups, UNSPECIFIED_TYPE):\n            fields = self._fields\n        else:\n            fields = self._groups[self._current_group]._fields  # type: ignore\n\n        for field in fields.values():\n            if isinstance(field, Field) and not isinstance(field.reference, UNSPECIFIED_TYPE):\n                field.value = field.reference(self)\n\n            elif isinstance(field, Field) and not isinstance(field.reference_root, UNSPECIFIED_TYPE):\n                field.value = field.reference_root(_root)\n\n            elif isinstance(field, Config):\n                field.resolve_references(_root=_root)\n\n    def print_help(self, _path: str = \"\", _group_prefix: str = \"\", _root: bool = True) -&gt; None:\n        if _root:\n            print(f\"Usage python {sys.argv[0]} [OPTIONS]\")\n\n        field_fields = [(field_name, field) for field_name, field in self._fields.items() if isinstance(field, Field)]\n        config_fields = [(field_name, field) for field_name, field in self._fields.items() if isinstance(field, Config)]\n        groups = (\n            [(group_name, group) for group_name, group in self._groups.items()]\n            if not isinstance(self._groups, UNSPECIFIED_TYPE)\n            else []\n        )\n\n        print_space = True\n\n        if _group_prefix:\n            print(f\"\\n{_group_prefix}\")\n            print_space = False\n\n        for field_name, field in field_fields:\n            default = UNSPECIFIED\n            if not isinstance(field.default, UNSPECIFIED_TYPE):\n                default = field.default\n            elif not isinstance(field.default_factory, UNSPECIFIED_TYPE):\n                default = field.default_factory()\n            help_text = \"\"\n            if not isinstance(field.help, UNSPECIFIED_TYPE):\n                help_text = f\"\\t\\t\\t{field.help}\"\n\n            if print_space:\n                print()\n                print_space = False\n            print(f\"--{_path}{field_name} {default}{help_text}\")\n\n        for field_name, field in config_fields:\n            field.print_help(_path=_path + field_name + \".\", _root=False)\n\n        for group_name, group in groups:\n            group.print_help(_path, f\"if --{_path[:-1]} {group_name}\", _root=False)\n\n    @classmethod\n    def from_dict(cls, d: dict) -&gt; \"Config\":\n        cfg_dict = {k: v if not isinstance(v, dict) else Config.from_dict(v) for k, v in d.items()}\n        return Config(**cfg_dict)  # type: ignore\n\n    def to_dict(self) -&gt; dict:\n        def format_value(v):\n            if isinstance(v, Field):\n                return v.value\n            elif isinstance(v, Config):\n                return v.to_dict()\n            else:\n                return v\n\n        if isinstance(self._groups, UNSPECIFIED_TYPE):\n            return {k: format_value(v) for k, v in self._fields.items()}\n        else:\n            group = self._groups[self._current_group]  # type: ignore\n            return {k: format_value(v) for k, v in group._fields.items()}\n\n    def __repr__(self) -&gt; str:\n        def normalize_values(d: dict):\n            return {\n                k: v if is_builtin(type(v)) else repr(v) if not isinstance(v, dict) else normalize_values(v) for k, v in d.items()\n            }\n\n        return yaml.dump(normalize_values(self.to_dict()), sort_keys=False).strip()\n\n    def __getattr__(self, __name: str) -&gt; Any:\n        if __name in self._fields:\n            v = self._fields[__name]\n            if isinstance(v, Field):\n                return v.value\n            elif isinstance(v, Config):\n                return v\n            else:\n                raise Exception(\"field values should only be Field's or Config's?\")\n\n        elif not isinstance(self._groups, UNSPECIFIED_TYPE):\n            return getattr(self._groups[self._current_group], __name)  # type: ignore\n\n        raise AttributeError(f\"{__name} not found. Fields: {list(self._fields.keys())}\")\n\n    def __setattr__(self, __name: str, __value: Any) -&gt; None:\n        if __name in {\n            \"_validate\",\n            \"_groups\",\n            \"_from_signature\",\n            \"_current_group\",\n            \"_fields\",\n        }:\n            super().__setattr__(__name, __value)\n\n        elif __name in self._fields:\n            orig_value = self._fields[__name].value\n            self._fields[__name].value = __value\n            if not isinstance(self._validate, UNSPECIFIED_TYPE):\n                if not self._validate(self):\n                    msg = f\"Config validation failed for {self.to_dict()}\"\n                    self._fields[__name].value = orig_value\n                    raise ValidationError(msg)\n\n        elif not isinstance(self._groups, UNSPECIFIED_TYPE):\n            setattr(self._groups[self._current_group], __name, __value)  # type: ignore\n\n        else:\n            raise AttributeError(f\"{__name} not found\")\n</code></pre>"},{"location":"API/#hydralette.Config.__init__","title":"<code>__init__(_validate=UNSPECIFIED, _groups=UNSPECIFIED, _from_signature=UNSPECIFIED, **_fields)</code>","text":"Source code in <code>hydralette/hydralette.py</code> <pre><code>def __init__(\n    self,\n    _validate: Callable[[Any], Any] | UNSPECIFIED_TYPE = UNSPECIFIED,\n    _groups: dict[str, Union[\"Config\", Any]] | UNSPECIFIED_TYPE = UNSPECIFIED,\n    _from_signature: Callable | UNSPECIFIED_TYPE = UNSPECIFIED,\n    **_fields,\n):\n    self._validate = _validate\n    self._groups = _groups\n    self._from_signature = _from_signature\n    self._fields = self._make_fields(_fields)\n\n    n_methods = sum(\n        (\n            not isinstance(self._groups, UNSPECIFIED_TYPE),\n            not isinstance(self._from_signature, UNSPECIFIED_TYPE),\n            len(self._fields) &gt; 0,\n        )\n    )\n    if n_methods &gt; 1:\n        raise MisconfigurationError(\"Can only specify one of (_groups, _from_signature, fields)\")\n\n    self._current_group = UNSPECIFIED\n    if not isinstance(self._groups, UNSPECIFIED_TYPE):\n        if \"_default\" not in self._groups:\n            raise MisconfigurationError(\"'_default' must be in _groups dict\")\n        self._current_group = self._groups.pop(\"_default\")\n        for key, group in self._groups.items():\n            if not isinstance(group, Config):\n                raise MisconfigurationError(f\"group value for '{key}'must be a Config\")\n\n    if not isinstance(self._from_signature, UNSPECIFIED_TYPE):\n        self._fields = fields_from_signature(inspect.signature(self._from_signature))\n</code></pre>"},{"location":"API/#hydralette.Config.apply","title":"<code>apply(overrides=sys.argv[1:])</code>","text":"Source code in <code>hydralette/hydralette.py</code> <pre><code>def apply(self, overrides: list[str] | dict = sys.argv[1:]) -&gt; None:\n    self.override(overrides)\n    self.resolve_references()\n    self.validate()\n    self.check_required_args()\n</code></pre>"},{"location":"API/#hydralette.Config.override","title":"<code>override(overrides=sys.argv[1:])</code>","text":"Source code in <code>hydralette/hydralette.py</code> <pre><code>def override(self, overrides: list[str] | dict = sys.argv[1:]) -&gt; None:\n    if isinstance(overrides, list):\n        if \"--help\" in overrides:\n            self.print_help()\n            sys.exit(0)\n\n        for i in range(0, len(overrides), 2):\n            key = overrides[i][2:]\n            value = overrides[i + 1]\n\n            if \".\" in key:\n                first_key = key.split(\".\")[0]\n                rest = \".\".join(key.split(\".\")[1:])\n\n                cfg = self if isinstance(self._groups, UNSPECIFIED_TYPE) else self._groups[self._current_group]  # type: ignore\n                if first_key not in cfg._fields:\n                    raise OverrideError(f\"Override key '{first_key}' not found\")\n                sub_cfg = cfg._fields[first_key]\n                if not isinstance(sub_cfg, Config):\n                    raise OverrideError(f\"Field '{first_key}' is not a Config\")\n                sub_cfg.override([f\"--{rest}\", value])\n\n            else:\n                if isinstance(self._groups, UNSPECIFIED_TYPE):\n                    if key not in self._fields:\n                        raise OverrideError(f\"Override key {key} not found\")\n\n                    child = self._fields[key]\n                    if isinstance(child, Field):\n                        child.value = child.convert_value(value)\n\n                    elif isinstance(child, Config):\n                        if isinstance(child._groups, UNSPECIFIED_TYPE):\n                            raise OverrideError(\"Can't override config unless it has groups\")\n                        elif value not in child._groups:\n                            raise OverrideError(f\"Group '{value}' does not exist\")\n                        child._current_group = value\n                else:\n                    fields = self._groups[self._current_group]._fields  # type: ignore\n                    if key not in fields:\n                        raise OverrideError(f\"Field '{key}' not found\")\n                    child = fields[key]\n                    if not isinstance(child, Field):\n                        raise OverrideError(\"Can't override config unless it has groups\")\n                    child.value = child.convert_value(value)\n\n    elif isinstance(overrides, Mapping):\n        # def flatten_dict(nested_dict, prefix='--'):\n        #     flattened = []\n        #     for key, value in nested_dict.items():\n        #         if isinstance(value, Mapping):\n        #             flattened.extend(flatten_dict(value, prefix + key + '.'))\n        #         else:\n        #             flattened.append(f'{prefix}{key} {value}')\n        #     return flattened\n\n        # self.override(flatten_dict(overrides))\n\n        # converting to string is problematic because values are converted to string --&gt; need to re-implement recursion for mappings\n        raise NotImplementedError(\"Overrides from mapping not supported yet\")\n</code></pre>"},{"location":"API/#hydralette.Config.check_required_args","title":"<code>check_required_args(_path='')</code>","text":"Source code in <code>hydralette/hydralette.py</code> <pre><code>def check_required_args(self, _path=\"\") -&gt; None:\n    for name, field in self._fields.items():\n        if isinstance(field, Field):\n            if isinstance(field.value, UNSPECIFIED_TYPE):\n                raise MissingArgumentError(f\"Required argument '{_path}{name}' is missing\")\n            if not isinstance(field.validate, UNSPECIFIED_TYPE) and not field.validate():  # type: ignore\n                raise ValidationError(f\"Field validation failed on '{_path}.{name}' for {field.value}\")\n\n        elif isinstance(field, Config):\n            field.check_required_args(_path=f\"{_path}{name}.\")\n</code></pre>"},{"location":"API/#hydralette.Config.validate","title":"<code>validate(_path='')</code>","text":"Source code in <code>hydralette/hydralette.py</code> <pre><code>def validate(self, _path=\"\") -&gt; None:\n    if not isinstance(self._validate, UNSPECIFIED_TYPE):\n        if not self._validate(self):\n            raise ValidationError(f\"Config validation failed for {self.to_dict()}\")\n\n    for name, field in self._fields.items():\n        if isinstance(field, Config):\n            field.check_required_args(_path=f\"{_path}{name}.\")\n</code></pre>"},{"location":"API/#hydralette.Config.resolve_references","title":"<code>resolve_references(_root=UNSPECIFIED)</code>","text":"Source code in <code>hydralette/hydralette.py</code> <pre><code>def resolve_references(self, _root: \"Config | UNSPECIFIED_TYPE\" = UNSPECIFIED) -&gt; None:\n    if isinstance(_root, UNSPECIFIED_TYPE):\n        _root = self\n\n    if isinstance(self._groups, UNSPECIFIED_TYPE):\n        fields = self._fields\n    else:\n        fields = self._groups[self._current_group]._fields  # type: ignore\n\n    for field in fields.values():\n        if isinstance(field, Field) and not isinstance(field.reference, UNSPECIFIED_TYPE):\n            field.value = field.reference(self)\n\n        elif isinstance(field, Field) and not isinstance(field.reference_root, UNSPECIFIED_TYPE):\n            field.value = field.reference_root(_root)\n\n        elif isinstance(field, Config):\n            field.resolve_references(_root=_root)\n</code></pre>"},{"location":"API/#hydralette.Config.print_help","title":"<code>print_help(_path='', _group_prefix='', _root=True)</code>","text":"Source code in <code>hydralette/hydralette.py</code> <pre><code>def print_help(self, _path: str = \"\", _group_prefix: str = \"\", _root: bool = True) -&gt; None:\n    if _root:\n        print(f\"Usage python {sys.argv[0]} [OPTIONS]\")\n\n    field_fields = [(field_name, field) for field_name, field in self._fields.items() if isinstance(field, Field)]\n    config_fields = [(field_name, field) for field_name, field in self._fields.items() if isinstance(field, Config)]\n    groups = (\n        [(group_name, group) for group_name, group in self._groups.items()]\n        if not isinstance(self._groups, UNSPECIFIED_TYPE)\n        else []\n    )\n\n    print_space = True\n\n    if _group_prefix:\n        print(f\"\\n{_group_prefix}\")\n        print_space = False\n\n    for field_name, field in field_fields:\n        default = UNSPECIFIED\n        if not isinstance(field.default, UNSPECIFIED_TYPE):\n            default = field.default\n        elif not isinstance(field.default_factory, UNSPECIFIED_TYPE):\n            default = field.default_factory()\n        help_text = \"\"\n        if not isinstance(field.help, UNSPECIFIED_TYPE):\n            help_text = f\"\\t\\t\\t{field.help}\"\n\n        if print_space:\n            print()\n            print_space = False\n        print(f\"--{_path}{field_name} {default}{help_text}\")\n\n    for field_name, field in config_fields:\n        field.print_help(_path=_path + field_name + \".\", _root=False)\n\n    for group_name, group in groups:\n        group.print_help(_path, f\"if --{_path[:-1]} {group_name}\", _root=False)\n</code></pre>"},{"location":"API/#hydralette.Config.from_dict","title":"<code>from_dict(d)</code>  <code>classmethod</code>","text":"Source code in <code>hydralette/hydralette.py</code> <pre><code>@classmethod\ndef from_dict(cls, d: dict) -&gt; \"Config\":\n    cfg_dict = {k: v if not isinstance(v, dict) else Config.from_dict(v) for k, v in d.items()}\n    return Config(**cfg_dict)  # type: ignore\n</code></pre>"},{"location":"API/#hydralette.Config.to_dict","title":"<code>to_dict()</code>","text":"Source code in <code>hydralette/hydralette.py</code> <pre><code>def to_dict(self) -&gt; dict:\n    def format_value(v):\n        if isinstance(v, Field):\n            return v.value\n        elif isinstance(v, Config):\n            return v.to_dict()\n        else:\n            return v\n\n    if isinstance(self._groups, UNSPECIFIED_TYPE):\n        return {k: format_value(v) for k, v in self._fields.items()}\n    else:\n        group = self._groups[self._current_group]  # type: ignore\n        return {k: format_value(v) for k, v in group._fields.items()}\n</code></pre>"},{"location":"API/#hydralette.Field","title":"<code>hydralette.Field</code>","text":"Source code in <code>hydralette/hydralette.py</code> <pre><code>class Field:\n    def __init__(\n        self,\n        type: type | UNSPECIFIED_TYPE = UNSPECIFIED,\n        default: Any | UNSPECIFIED_TYPE = UNSPECIFIED,\n        default_factory: Callable[[], Any] | UNSPECIFIED_TYPE = UNSPECIFIED,\n        convert: Callable[[str], Any] | UNSPECIFIED_TYPE = UNSPECIFIED,\n        validate: Callable[[Any], bool] | UNSPECIFIED_TYPE = UNSPECIFIED,\n        reference: Callable[[Config], Any] | UNSPECIFIED_TYPE = UNSPECIFIED,\n        reference_root: Callable[[Config], Any] | UNSPECIFIED_TYPE = UNSPECIFIED,\n        help: str | UNSPECIFIED_TYPE = UNSPECIFIED,\n    ):\n        self.type = type\n        self.default = default\n        self.default_factory = default_factory\n        self.convert = convert\n        self.validate = validate\n        self.help = help\n        self.reference = reference\n        self.reference_root = reference_root\n\n        self._value = None\n        _value = UNSPECIFIED\n        if not isinstance(default, UNSPECIFIED_TYPE):\n            _value = default\n        elif not isinstance(default_factory, UNSPECIFIED_TYPE):\n            _value = default_factory()\n        self.value = _value\n\n        if isinstance(self.type, UNSPECIFIED_TYPE) and not isinstance(self.value, UNSPECIFIED_TYPE):\n            self.type = builtins.type(self.value)\n\n    @classmethod\n    def from_signature_paramter(cls, parameter: inspect.Parameter) -&gt; \"Field\":\n        kwargs = {}\n\n        if parameter.annotation != inspect._empty:\n            kwargs[\"type\"] = parameter.annotation\n\n        if parameter.default != inspect._empty:\n            kwargs[\"default\"] = parameter.default\n        elif parameter.kind == inspect.Parameter.VAR_KEYWORD:\n            kwargs[\"default\"] = {}\n        elif parameter.kind == inspect.Parameter.VAR_POSITIONAL:\n            kwargs[\"default\"] = []\n\n        if \"default\" in kwargs and \"type\" not in kwargs:\n            kwargs[\"type\"] = type(kwargs[\"default\"])\n\n        return Field(**kwargs)\n\n    def convert_value(self, value: Any) -&gt; Any:\n        if not isinstance(self.convert, UNSPECIFIED_TYPE):\n            value = self.convert(value)\n\n        elif not isinstance(self.type, UNSPECIFIED_TYPE) and callable(self.type):\n            try:\n                value = self.type(value)\n            except:  # noqa\n                pass\n\n        return value\n\n    @property\n    def value(self):\n        return self._value\n\n    @value.setter\n    def value(self, v):\n        if not isinstance(self.validate, UNSPECIFIED_TYPE):\n            if not self.validate(v):\n                raise ValidationError(f\"Field validation failed for {v}\")\n        self._value = v\n\n    def __repr__(self):\n        return repr(self.value)\n</code></pre>"},{"location":"API/#hydralette.Field.value","title":"<code>value</code>  <code>property</code> <code>writable</code>","text":""},{"location":"API/#hydralette.Field.__init__","title":"<code>__init__(type=UNSPECIFIED, default=UNSPECIFIED, default_factory=UNSPECIFIED, convert=UNSPECIFIED, validate=UNSPECIFIED, reference=UNSPECIFIED, reference_root=UNSPECIFIED, help=UNSPECIFIED)</code>","text":"Source code in <code>hydralette/hydralette.py</code> <pre><code>def __init__(\n    self,\n    type: type | UNSPECIFIED_TYPE = UNSPECIFIED,\n    default: Any | UNSPECIFIED_TYPE = UNSPECIFIED,\n    default_factory: Callable[[], Any] | UNSPECIFIED_TYPE = UNSPECIFIED,\n    convert: Callable[[str], Any] | UNSPECIFIED_TYPE = UNSPECIFIED,\n    validate: Callable[[Any], bool] | UNSPECIFIED_TYPE = UNSPECIFIED,\n    reference: Callable[[Config], Any] | UNSPECIFIED_TYPE = UNSPECIFIED,\n    reference_root: Callable[[Config], Any] | UNSPECIFIED_TYPE = UNSPECIFIED,\n    help: str | UNSPECIFIED_TYPE = UNSPECIFIED,\n):\n    self.type = type\n    self.default = default\n    self.default_factory = default_factory\n    self.convert = convert\n    self.validate = validate\n    self.help = help\n    self.reference = reference\n    self.reference_root = reference_root\n\n    self._value = None\n    _value = UNSPECIFIED\n    if not isinstance(default, UNSPECIFIED_TYPE):\n        _value = default\n    elif not isinstance(default_factory, UNSPECIFIED_TYPE):\n        _value = default_factory()\n    self.value = _value\n\n    if isinstance(self.type, UNSPECIFIED_TYPE) and not isinstance(self.value, UNSPECIFIED_TYPE):\n        self.type = builtins.type(self.value)\n</code></pre>"}]}