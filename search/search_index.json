{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#hydralette","title":"Hydralette","text":"<p>Create complex configurations in a simple, pythonic way!</p> <p> </p>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install hydralette\n# OR\npoetry add hydralette\n</code></pre>"},{"location":"#changelog","title":"Changelog","text":"<ul> <li>v0.1.3 at commit <code>90655ca</code><ul> <li>Add automatic generation of configs from signatures via <code>from_signature</code> and <code>config_from_signature</code></li> </ul> </li> <li>v0.1.2 at commit <code>5848f43</code><ul> <li>Add support for <code>config groups</code>, <code>references</code>, <code>validation</code> and <code>type conversion</code></li> <li>Add CLI help pages</li> </ul> </li> </ul>"},{"location":"#features","title":"Features","text":"<ul> <li>[x] Build configs like dataclasses | Brief Example</li> <li>[x] Automatically generate configs from class/function signatures | Brief Example | Complete Example</li> <li>[x] Effortless CLI from Config classes | Brief Example</li> <li>[x] Config groups to swap whole components | Brief Example | Complete Example</li> <li>[x] Referencing other config values to reduce redundancy | Brief Example | Complete Example</li> <li>[x] Type Conversion from CLI | Brief Example | Complete Example</li> <li>[x] Value Validation | Brief Example | Complete Example</li> <li>[ ] Load and save yaml files</li> <li>[ ] Automatic instantiation</li> </ul>"},{"location":"API/","title":"API Reference","text":""},{"location":"API/#hydralette.ConfigBase","title":"<code>hydralette.ConfigBase</code>","text":"<p>Base Class for hydralette configs.</p> <p>Create a subclass of this and define fields just like with dataclasses.</p> Example <pre><code>from hydralette import ConfigBase, field\nclass Config(ConfigBase):\nx: int = field(\ndefault=1,\nvalidate=lambda x: x &gt; 0\n)\n</code></pre> Warning <p>Using the constructor to instantiate a config is not recommended. Use <code>ConfigClass.create</code> to use hydralettes full features.</p> Source code in <code>hydralette/config.py</code> <pre><code>class ConfigBase(metaclass=ConfigMeta):\n\"\"\"Base Class for hydralette configs.\n    Create a subclass of this and define fields just like with dataclasses.\n    Example:\n        ```python\n        from hydralette import ConfigBase, field\n        class Config(ConfigBase):\n            x: int = field(\n                default=1,\n                validate=lambda x: x &gt; 0\n            )\n        ```\n    Warning:\n        Using the constructor to instantiate a config is not recommended. Use `ConfigClass.create` to use hydralettes full features.\n    \"\"\"\n@classmethod\ndef create(cls: Type[T], overrides: List[str] = sys.argv[1:]) -&gt; T:\n\"\"\"Entry point to instantiate a config.\n        Args:\n            cls (Type[T]): ConfigClass\n            overrides (_type_, optional): Overrides in the format `arg.subarg=value`. Defaults to `sys.argv[1:]`.\n        Raises:\n            ValueError: If `cls` is not a subclass of ConfigBase\n            SystemExit: After printing the help page\n        Returns:\n            T: Instance of the ConfigClass\n        \"\"\"\nif not issubclass(cls, ConfigBase):\nraise ValueError(f\"Type '{cls}' is not a subclass of ConfigBase\")\nfor help_flag in (\"--help\", \"-h\"):\nif help_flag in overrides:\ncls.print_help_page()\nraise SystemExit(0)\nconfig = cls.parse_and_instantiate(overrides)\nconfig.resolve_references()\nconfig.instance_validation()\nreturn config\n@classmethod\ndef parse_and_instantiate(cls: Type[T], overrides: List[str] = sys.argv[1:]) -&gt; T:\n\"\"\"Parse overrides and recursively instantiate config.\n        Args:\n            cls (Type[T]): _description_\n            overrides (_type_, optional): _description_. Defaults to sys.argv[1:].\n        Raises:\n            ValueError: _description_\n            HydraletteConfigurationError: _description_\n        Returns:\n            T: _description_\n        \"\"\"\nkwargs = {}\nsub_config_overrides = defaultdict(list)\nsub_config_types = defaultdict()\n# parse overrides\nfor override in overrides:\nkey, value = override.split(\"=\")\nsubkeys = key.split(\".\")\n# Match key to the corresponding field\nmatched_field = None\nmatched_fields = [field for field in fields(cls) if field.name == key]\nmatched_sub_fields = [field for field in fields(cls) if field.name == subkeys[0]]\nif matched_fields:\nmatched_field = matched_fields[0]\ntop_level = True\nelif matched_sub_fields:\nmatched_field = matched_sub_fields[0]\ntop_level = False\nelse:\nraise ValueError(f\"Key '{key}' could not be found in {cls}\")\n# top level primitive assignments: key=val\nif top_level and not is_hydralette_config(matched_field.type):\nkwargs[key] = convert_type(matched_field, value)\n# config groups: key=group_name\nelif top_level and is_hydralette_config(matched_field.type):\nif value not in matched_field.groups:\nraise HydraletteConfigurationError(\nf\"Invalid group '{value}' for field '{matched_field.name}' \" f\"in '{cls.__module__}.{cls.__name__}'\"\n)\nsub_config_types[key] = matched_field.groups[value]\n# sub level assignments: subkey[0].subkey[1]=val\nelse:\nif subkeys[0] not in sub_config_types:\nif matched_field.groups:\nfield_type = matched_field.default\nelse:\nfield_type = matched_field.type\nsub_config_types[subkeys[0]] = field_type\nsub_config_overrides[subkeys[0]].append(f\"{'.'.join(subkeys[1:])}={value}\")\n# create sub configs that do not have overrides\nfor f in fields(cls):\nif f.name not in sub_config_overrides and f.groups:\nkwargs[f.name] = f.default()  # type: ignore\n# create sub configs that have overrides\nfor key, sub_cls in sub_config_types.items():\nkwargs[key] = sub_cls.parse_and_instantiate(sub_config_overrides[key])  # type: ignore\nconfig = cls(**kwargs)\nreturn config\n@classmethod\ndef print_help_page(cls) -&gt; None:\nprinted = []\ndef format_type_info(t) -&gt; str:\nif get_origin(t) is Union:\nreturn f\"Union[{', '.join(st.__name__ for st in get_args(t))}]\"\nelif hasattr(t, \"__name__\"):\nreturn t.__name__\nelse:\nreturn \"\"\ndef print_options_for_class(cls, trace, group_info=\"\", super_class=None):\nif cls in printed:\nreturn\nif group_info:\ngroup_info = f\" ({group_info})\"\nname = cls.__module__ + \".\" + cls.__name__\nprint(f\"Options from '{name}'{group_info}:\")\nfor f in fields(cls):\nif super_class is not None and f.name in [f.name for f in fields(super_class)]:\ncontinue\nhelp = f.metadata.get(\"help\", \"\")\nif is_hydralette_config(f.type) and help:\narg_descr = f\"Options see below. {help}\"\nelif is_hydralette_config(f.type) and not help:\narg_descr = \"Options see below.\"\nelse:\narg_descr = help\n_trace = trace + \".\" if trace else \"\"\ntype_fmt = format_type_info(f.type)\ndefault = \"\"\nif f.default is not DC_MISSING:\ndefault = f\" = {f.default}\"\nelif f.default_factory is not DC_MISSING:\ndf_name = f.default_factory.__name__  # type: ignore\nif df_name == \"&lt;lambda&gt;\":\ndf = inspect.getsource(f.default_factory)\ndf = df[df.find(\"lambda\") :].strip()\nif df == \"lambda: T()\":\ndf = f\"lambda: {f.type.__name__}()\"\nelse:\ndf = f\"{df_name}()\"\ndefault = f\" = {df}\"\narg_name = f\"{_trace}{f.name}: {type_fmt}{default} \"\nprint(f\"\\t{arg_name:70s}{arg_descr}\")\nprinted.append(cls)\nprint()\nsub_config_fields = [field for field in fields(cls) if is_hydralette_config(field.type)]\nfor f in sub_config_fields:\n_trace = trace + \".\" if trace else \"\"\nif f.groups:\nfor key, typ in f.groups.items():\nprint_options_for_class(typ, f\"{_trace}{f.name}\", f\"active if '{f.name}={key}'\")\nelse:\nprint_options_for_class(f.type, f\"{_trace}{f.name}\")\nprint(f\"Usage: python {sys.argv[0]} [option=value]\\n\")\nprint_options_for_class(cls, \"\")\n@classmethod\ndef class_validation(cls):\nfor f in fields(cls):\n# Check that groups have a default config class\nif f.groups and not (isinstance(f.default, type) and issubclass(f.default, ConfigBase)):\nraise HydraletteConfigurationError(\nf\"'{cls.__module__}.{cls.__name__}.{f.name}' is a group\"\n\" but no proper default value is supplied. Pass the default config class (not instance!) \"\n\"as default argument: 'default=YourDefaultConfig'.\"\n)\ndef instance_validation(self):\nfor f in fields(self):\ncls = self.__class__\nvalue = getattr(self, f.name)\n# Check for missing arguments\nif value is MISSING:\nraise HydraletteConfigurationError(\nf\"'{cls.__module__}.{cls.__name__}' is missing the required argument '{f.name}'\"\n)\nif f.validate is not None and not f.validate(value):\nraise HydraletteConfigurationError(\nf\"Value '{value}' invalid for argument '{f.name}' in '{cls.__module__}.{cls.__name__}'\"\n)\nelif isinstance(value, ConfigBase):\nvalue.instance_validation()\ndef to_dict(self, only_repr=False) -&gt; Dict[str, Any]:\nreturn {field.name: _get_attr(self, field.name, only_repr=only_repr) for field in fields(self)}\ndef to_yaml(self, sort_keys=False, only_repr=False) -&gt; str:\nd = self.to_dict(only_repr=only_repr)\nreturn yaml.dump(d, sort_keys=sort_keys)\ndef print_yaml(self):\nprint(self.to_yaml(only_repr=True))\ndef resolve_references(self, root_config=None):\nif root_config is None:\nroot_config = self\nfor f in fields(self):  # type: ignore\nvalue = getattr(self, f.name)\nif f.reference is not None:\nsetattr(self, f.name, f.reference(root_config))\nelif is_hydralette_config(value):\nvalue.resolve_references(root_config=root_config)\ndef __getattribute__(self, __name: str) -&gt; Any:  # silence static type checker when fields from signature are accessed\nreturn super().__getattribute__(__name)\n</code></pre>"},{"location":"API/#hydralette.ConfigBase.create","title":"<code>create(overrides=sys.argv[1:])</code>  <code>classmethod</code>","text":"<p>Entry point to instantiate a config.</p> <p>Parameters:</p> Name Type Description Default <code>cls</code> <code>Type[T]</code> <p>ConfigClass</p> required <code>overrides</code> <code>_type_</code> <p>Overrides in the format <code>arg.subarg=value</code>. Defaults to <code>sys.argv[1:]</code>.</p> <code>argv[1:]</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>cls</code> is not a subclass of ConfigBase</p> <code>SystemExit</code> <p>After printing the help page</p> <p>Returns:</p> Name Type Description <code>T</code> <code>T</code> <p>Instance of the ConfigClass</p> Source code in <code>hydralette/config.py</code> <pre><code>@classmethod\ndef create(cls: Type[T], overrides: List[str] = sys.argv[1:]) -&gt; T:\n\"\"\"Entry point to instantiate a config.\n    Args:\n        cls (Type[T]): ConfigClass\n        overrides (_type_, optional): Overrides in the format `arg.subarg=value`. Defaults to `sys.argv[1:]`.\n    Raises:\n        ValueError: If `cls` is not a subclass of ConfigBase\n        SystemExit: After printing the help page\n    Returns:\n        T: Instance of the ConfigClass\n    \"\"\"\nif not issubclass(cls, ConfigBase):\nraise ValueError(f\"Type '{cls}' is not a subclass of ConfigBase\")\nfor help_flag in (\"--help\", \"-h\"):\nif help_flag in overrides:\ncls.print_help_page()\nraise SystemExit(0)\nconfig = cls.parse_and_instantiate(overrides)\nconfig.resolve_references()\nconfig.instance_validation()\nreturn config\n</code></pre>"},{"location":"API/#hydralette.ConfigBase.to_dict","title":"<code>to_dict(only_repr=False)</code>","text":"Source code in <code>hydralette/config.py</code> <pre><code>def to_dict(self, only_repr=False) -&gt; Dict[str, Any]:\nreturn {field.name: _get_attr(self, field.name, only_repr=only_repr) for field in fields(self)}\n</code></pre>"},{"location":"API/#hydralette.ConfigBase.to_yaml","title":"<code>to_yaml(sort_keys=False, only_repr=False)</code>","text":"Source code in <code>hydralette/config.py</code> <pre><code>def to_yaml(self, sort_keys=False, only_repr=False) -&gt; str:\nd = self.to_dict(only_repr=only_repr)\nreturn yaml.dump(d, sort_keys=sort_keys)\n</code></pre>"},{"location":"API/#hydralette.ConfigBase.print_yaml","title":"<code>print_yaml()</code>","text":"Source code in <code>hydralette/config.py</code> <pre><code>def print_yaml(self):\nprint(self.to_yaml(only_repr=True))\n</code></pre>"},{"location":"API/#hydralette.field","title":"<code>hydralette.field(*, reference=None, convert=None, validate=None, groups={}, from_signature=None, default=MISSING, default_factory=MISSING, init=True, repr=True, hash=None, compare=True, metadata=None, kw_only=MISSING)</code>","text":"Source code in <code>hydralette/hydralette_field.py</code> <pre><code>def field(\n*,\nreference: Optional[Callable] = None,\nconvert: Optional[Callable] = None,\nvalidate: Optional[Callable] = None,\ngroups: Dict[str, type] = {},\nfrom_signature: Optional[Callable] = None,\ndefault=MISSING,\ndefault_factory=MISSING,\ninit=True,\nrepr=True,\nhash=None,\ncompare=True,\nmetadata=None,\nkw_only=MISSING,\n) -&gt; Any:\nif from_signature is not None:\nif default_factory is not MISSING:\nlog.warn(\"'from_signature' and 'default_factory' are not compatible.\")\nif default is not MISSING:\nlog.warn(\"'from_signature' and 'default' are not compatible.\")\nreturn HydraletteField.from_signature(\nfrom_signature,\nfield_kwargs=dict(\nreference=reference,\nconvert=convert,\nvalidate=validate,\ngroups=groups,\ninit=init,\nrepr=repr,\nhash=hash,\ncompare=compare,\nmetadata=metadata,\nkw_only=kw_only,\n),\n)\nif reference is not None and default is MISSING and default_factory is MISSING:\n# Avoid error from dataclasses that non-default arguments cannot follow default arguments\n# default value is irrelevant anyway, since the value will be determined by the reference lambda\ndefault = None\nreturn HydraletteField(\nreference=reference,\nconvert=convert,\nvalidate=validate,\ngroups=groups,\ndefault=default,\ndefault_factory=default_factory,\ninit=init,\nrepr=repr,\nhash=hash,\ncompare=compare,\nmetadata=metadata,\nkw_only=kw_only,\n)\n</code></pre>"},{"location":"API/#hydralette.fields","title":"<code>hydralette.fields(class_or_instance)</code>","text":"Source code in <code>hydralette/hydralette_field.py</code> <pre><code>def fields(class_or_instance) -&gt; Tuple[HydraletteField]:\nreturn dc_fields(class_or_instance)  # type: ignore\n</code></pre>"},{"location":"API/#hydralette.config_from_signature","title":"<code>hydralette.config_from_signature(callable)</code>","text":"Source code in <code>hydralette/config.py</code> <pre><code>def config_from_signature(callable: Callable) -&gt; Type[ConfigBase]:\nannotations = {\nparameter.name: parameter._annotation if parameter._annotation is not inspect._empty else Any\nfor parameter in inspect.signature(callable)._parameters.values()  # type: ignore\n}\ndunders = {\"__annotations__\": annotations}\nif hasattr(callable, \"__module__\"):\ndunders[\"__module__\"] = callable.__module__  # type: ignore\nfields = {\nparameter.name: field(default=parameter.default if parameter.default is not inspect._empty else MISSING)\nfor parameter in inspect.signature(callable)._parameters.values()  # type: ignore\n}\nT = type(f\"{callable.__name__}Hydralette\", (ConfigBase,), {**dunders, **fields})\nreturn T\n</code></pre>"},{"location":"API/#hydralette.HydraletteConfigurationError","title":"<code>hydralette.HydraletteConfigurationError</code>","text":"<p>             Bases: <code>Exception</code></p> Source code in <code>hydralette/exceptions.py</code> <pre><code>class HydraletteConfigurationError(Exception):\npass\n</code></pre>"},{"location":"API/#hydralette.MISSING","title":"<code>hydralette.MISSING = MISSING_TYPE()</code>  <code>module-attribute</code>","text":"<p>Flag to indicate that a field is required.</p>"},{"location":"examples/","title":"Examples","text":""},{"location":"examples/#minimal-example","title":"Minimal Example","text":"<p>Hydralette configs are defined similar to dataclasses. Instead of decorating your class with <code>@dataclass</code>, derive it from <code>ConfigBase</code>.</p> <pre><code>from hydralette import ConfigBase, field, MISSING\nclass ModelConfig(ConfigBase):\nn_layers: int = field(\ndefault=32,\nmetadata=dict(help=\"Number of Layers\")\n)\ndropout: float = field(\ndefault=0.1,\nmetadata=dict(help=\"Dropout p value\")\n)\nif __name__ == \"__main__\":\nconfig = ModelConfig.create()\n</code></pre>"},{"location":"examples/#hierarchical-configs","title":"Hierarchical Configs","text":"<p>Note</p> <p>Complete example in examples/01_getting_started.py</p> <pre><code>class ModelConfig(ConfigBase):\nn_layers: int = field(\ndefault=32,\nmetadata=dict(help=\"Number of Layers\")\n)\ndropout: float = field(\ndefault=0.1,\nmetadata=dict(help=\"Dropout p value\")\n)\nclass Config(ConfigBase):\noutput_dir: Path = field(\ndefault=Path(\"output\"),\nmetadata=dict(help=\"Ouput directory to save all results to\")\n)\nmodel: ModelConfig = field(  # &lt;-- specify another config class as field type to make the config hierarchical\ndefault_factory=lambda: ModelConfig(),\nmetadata=dict(help=\"Config for model\")\n)\n</code></pre>"},{"location":"examples/#from-signature","title":"From Signature","text":"<p>Note</p> <p>Complete example in examples/06_from_signature.py</p> <p>Warning</p> <p>Static analysis and auto-complete does not work with dynamically generated config classes.</p> <p>If you already have an interface defined in the signature of a class or function, you can directly create your config from that without the need for duplicate code.</p> <pre><code>class Config(ConfigBase):\nmyclass = field(\nfrom_signature=MyClass,  # &lt;-- generate config class from constructor signature and use as field\nmetadata=dict(help=\"This is helpful text\"),\n)\nmy_func = field(from_signature=my_func)  # &lt;-- generate config class from function signature and use as field\n</code></pre>"},{"location":"examples/#cli","title":"CLI","text":"<p>All config fields can be overriden via the CLI. To make a field mandatory set its default to <code>hydralette.MISSING</code>.</p> <pre><code>from hydralette import ConfigBase, field, MISSING\nclass ModelConfig(ConfigBase):\nn_layers: int = field(\ndefault=32,\nmetadata=dict(help=\"Number of Layers\")\n)\ndropout: float = field(\ndefault=MISSING,     # &lt;-- required argument\nmetadata=dict(help=\"Dropout p value\")\n)\nclass Config(ConfigBase):\noutput_dir: Path = field(\ndefault=Path(\"output\"),\nmetadata=dict(help=\"Ouput directory to save all results to\")\n)\nmodel: ModelConfig = field(\ndefault_factory=lambda: ModelConfig(),\nmetadata=dict(help=\"Config for model\")\n)\nif __name__ == \"__main__\":\nconfig = Config.create()\n</code></pre> <pre><code>$ python example.py -h\nUsage: python test.py [option=value]\nOptions from '__main__.Config':\n        output_dir: Path                                       Ouput directory to save all results to\n        model: ModelConfig                                     Options see below\n\nOptions from '__main__.ModelConfig':\n        model.n_layers: int                                    Number of Layers\n        model.dropout: float                                   Dropout p value\n</code></pre>"},{"location":"examples/#config-groups","title":"Config Groups","text":"<p>Note</p> <p>Complete example in examples/02_groups.py</p> <p>When configuring heterogeneous applications with interchangable parts, shared configurations can get messy. Different components might fulfill the same purpose but still require very different configuration paramters. Hydralette supports config groups to disentangle such configs. Components can then swapped with a single CLI override.</p> <pre><code>class TransformerModelConfig(ConfigBase):\nn_layers: int = field(\ndefault=32,\nmetadata=dict(help=\"Number of Transformer Layers\")\n)\nnum_attention_heads: int = field(\ndefault=8,\nmetadata=dict(help=\"Number of Attention Heads per Layer\")\n)\nclass RNNModelConfig(ConfigBase):\nn_layers: int = field(\ndefault=4,\nmetadata=dict(help=\"Number of RNN Layers\")\n)\nbidirectional: bool = field(\ndefault=True,\nmetadata=dict(help=\"Bidirectional or Unidirectional RNN Layers\")\n)\nclass Config(ConfigBase):\noutput_dir: Path = field(\ndefault=Path(\"output\"),\nmetadata=dict(help=\"Ouput directory to save all results to\")\n)\nmodel: Union[TransformerModelConfig, RNNModelConfig] = field(\ndefault=RNNModelConfig,                                              # &lt;-- default config class\nmetadata=dict(help=\"Config for model\"),\ngroups=dict(transformer=TransformerModelConfig, rnn=RNNModelConfig), # &lt;-- &lt;key&gt;=&lt;config class&gt;\n)\nif __name__ == \"__main__\":\nconfig = Config.create()\nconfig.print_yaml()\n</code></pre> <pre><code>$ python test.py model=transformer\n\noutput_dir: PosixPath('output')\nmodel:\n  n_layers: 32\nnum_attention_heads: 8\n</code></pre>"},{"location":"examples/#compatibility-with-pure-dataclasses","title":"Compatibility with pure dataclasses","text":"<p>Note</p> <p>Complete example in examples/03_existing_dataclass.py</p> <p>Some libraries define their configuration as dataclasses. To use an existing dataclass as hydralette config, simply derive from it and <code>ConfigBase</code>.</p> <pre><code>from library import LibraryConfig\nclass MyConfig(LibraryConfig, ConfigBase):\npass\n</code></pre>"},{"location":"examples/#references","title":"References","text":"<p>Note</p> <p>Complete example in examples/04_references.py</p> <p>Sometimes a configuration value is required by multiple components. To avoid defining and overriding it in multiple places, simply reference a single source of truth. The <code>reference</code> API works with functions that take the main config as input and output and arbitrary value, so you can add things and combine multiple other values.</p> <pre><code>class Config(ConfigBase):\noutput_dir: Path = field(\ndefault=Path(\"output\"),\nmetadata=dict(help=\"Output directory to save all results to\")\n)\nrun_name: str = field(\ndefault=\"run-001\",\nmetadata=dict(help=\"Name of the run\")\n)\ncheckpoint_dir: Path = field(\nreference=lambda cfg: cfg.output_dir / cfg.run_name / \"checkpoints\"\n)\n</code></pre>"},{"location":"examples/#type-conversion","title":"Type Conversion","text":"<p>Values from the CLI need to converted to their correct type. If the type annotation already works as converter, types will be automatically converted. Alternatively, you can also provide a conversion function via <code>convert</code>.</p> <pre><code>class Config(ConfigBase):\noutput_dir: Path = field(\ndefault=Path(\"~/output\").expanduser(),\nmetadata=dict(help=\"Output directory to save all results to\"),\nconvert=lambda value: Path(value).expanduser()      # custom type conversion to add expanduser\n)\n</code></pre>"},{"location":"examples/#validation","title":"Validation","text":"<p>Every field can be validated by passing a lambda with signature <code>(value) -&gt; (bool)</code> to <code>validate</code>.</p> <pre><code>class Config(ConfigBase):\nn_layers: int = field(\ndefault=32,\nmetadata=dict(help=\"Number of Layers\"),\nvalidate=lambda value: value &gt; 0\n)\n</code></pre>"}]}