{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#hydralette","title":"Hydralette","text":"<p>Create complex configurations in a simple, pythonic way!</p> <p> </p>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install hydralette\n# OR\npoetry add hydralette\n</code></pre>"},{"location":"#changelog","title":"Changelog","text":"<ul> <li>v0.1.3 at commit <code>90655ca</code><ul> <li>Add automatic generation of configs from signatures via <code>from_signature</code> and <code>config_from_signature</code></li> </ul> </li> <li>v0.1.2 at commit <code>5848f43</code><ul> <li>Add support for <code>config groups</code>, <code>references</code>, <code>validation</code> and <code>type conversion</code></li> <li>Add CLI help pages</li> </ul> </li> </ul>"},{"location":"#features","title":"Features","text":"<ul> <li>[x] Build configs like dataclasses | Brief Example</li> <li>[x] Automatically generate configs from class/function signatures | Brief Example | Complete Example</li> <li>[x] Effortless CLI from Config classes | Brief Example</li> <li>[x] Config groups to swap whole components | Brief Example | Complete Example</li> <li>[x] Referencing other config values to reduce redundancy | Brief Example | Complete Example</li> <li>[x] Type Conversion from CLI | Brief Example | Complete Example</li> <li>[x] Value Validation | Brief Example | Complete Example</li> <li>[ ] Load and save yaml files</li> <li>[ ] Automatic instantiation</li> </ul>"},{"location":"API/","title":"API Reference","text":""},{"location":"API/#hydralette.ConfigBase","title":"<code>hydralette.ConfigBase</code>","text":"<p>Base Class for hydralette configs.</p> <p>Create a subclass of this and define fields just like with dataclasses.</p> Example <pre><code>from hydralette import ConfigBase, field\nclass Config(ConfigBase):\nx: int = field(\ndefault=1,\nvalidate=lambda x: x &gt; 0\n)\n</code></pre> Warning <p>Using the constructor to instantiate a config is not recommended. Use <code>ConfigClass.create</code> to use hydralettes full features.</p> Source code in <code>hydralette/config.py</code> <pre><code>class ConfigBase(metaclass=ConfigMeta):\n\"\"\"Base Class for hydralette configs.\n    Create a subclass of this and define fields just like with dataclasses.\n    Example:\n        ```python\n        from hydralette import ConfigBase, field\n        class Config(ConfigBase):\n            x: int = field(\n                default=1,\n                validate=lambda x: x &gt; 0\n            )\n        ```\n    Warning:\n        Using the constructor to instantiate a config is not recommended. Use `ConfigClass.create` to use hydralettes full features.\n    \"\"\"\n@classmethod\ndef create(cls: Type[T], overrides: List[str] = sys.argv[1:]) -&gt; T:\n\"\"\"Entry point to instantiate a config.\n        Args:\n            overrides (List[str], optional): Overrides in the format `arg.subarg=value`. Defaults to `sys.argv[1:]`.\n        Raises:\n            ValueError: If `cls` is not a subclass of ConfigBase\n            SystemExit: After printing the help page\n        Returns:\n            T: Instance of the ConfigClass\n        \"\"\"\nif not issubclass(cls, ConfigBase):\nraise ValueError(f\"Type '{cls}' is not a subclass of ConfigBase\")\nfor help_flag in (\"--help\", \"-h\"):\nif help_flag in overrides:\ncls.print_help_page()\nraise SystemExit(0)\nconfig = cls.parse_and_instantiate(overrides)\nconfig.resolve_references()\nconfig.instance_validation()\nreturn config\n@classmethod\ndef parse_and_instantiate(cls: Type[T], overrides: List[str] = sys.argv[1:]) -&gt; T:\n\"\"\"Parse overrides and recursively instantiate config.\n        Args:\n            cls (Type[T]): _description_\n            overrides (_type_, optional): _description_. Defaults to sys.argv[1:].\n        Raises:\n            ValueError: _description_\n            HydraletteConfigurationError: _description_\n        Returns:\n            T: _description_\n        \"\"\"\nkwargs = {}\nsub_config_overrides = defaultdict(list)\nsub_config_types = defaultdict()\n# parse overrides\nfor override in overrides:\nkey, value = override.split(\"=\")\nsubkeys = key.split(\".\")\n# Match key to the corresponding field\nmatched_field = None\nmatched_fields = [field for field in fields(cls) if field.name == key]\nmatched_sub_fields = [field for field in fields(cls) if field.name == subkeys[0]]\nif matched_fields:\nmatched_field = matched_fields[0]\ntop_level = True\nelif matched_sub_fields:\nmatched_field = matched_sub_fields[0]\ntop_level = False\nelse:\nraise ValueError(f\"Key '{key}' could not be found in {cls}\")\n# top level primitive assignments: key=val\nif top_level and not is_hydralette_config(matched_field.type):\nkwargs[key] = convert_type(matched_field, value)\n# config groups: key=group_name\nelif top_level and is_hydralette_config(matched_field.type):\nif value not in matched_field.groups:\nraise HydraletteConfigurationError(\nf\"Invalid group '{value}' for field '{matched_field.name}' \" f\"in '{cls.__module__}.{cls.__name__}'\"\n)\nsub_config_types[key] = matched_field.groups[value]\n# sub level assignments: subkey[0].subkey[1]=val\nelse:\nif subkeys[0] not in sub_config_types:\nif matched_field.groups:\nfield_type = matched_field.default\nelse:\nfield_type = matched_field.type\nsub_config_types[subkeys[0]] = field_type\nsub_config_overrides[subkeys[0]].append(f\"{'.'.join(subkeys[1:])}={value}\")\n# create sub configs that do not have overrides\nfor f in fields(cls):\nif f.name not in sub_config_overrides and f.groups:\nkwargs[f.name] = f.default()  # type: ignore\n# create sub configs that have overrides\nfor key, sub_cls in sub_config_types.items():\nkwargs[key] = sub_cls.parse_and_instantiate(sub_config_overrides[key])  # type: ignore\nconfig = cls(**kwargs)\nreturn config\n@classmethod\ndef print_help_page(cls) -&gt; None:\n\"\"\"Print the help page. Is called automatically by `.create()` if `-h` or `--help` is in the overrides.\"\"\"\nprinted = []\ndef format_type_info(t) -&gt; str:\nif get_origin(t) is Union:\nreturn f\"Union[{', '.join(st.__name__ for st in get_args(t))}]\"\nelif hasattr(t, \"__name__\"):\nreturn t.__name__\nelse:\nreturn \"\"\ndef print_options_for_class(cls, trace, group_info=\"\", super_class=None):\nif cls in printed:\nreturn\nif group_info:\ngroup_info = f\" ({group_info})\"\nname = cls.__module__ + \".\" + cls.__name__\nprint(f\"Options from '{name}'{group_info}:\")\nfor f in fields(cls):\nif super_class is not None and f.name in [f.name for f in fields(super_class)]:\ncontinue\nhelp = f.metadata.get(\"help\", \"\")\nif is_hydralette_config(f.type) and help:\narg_descr = f\"Options see below. {help}\"\nelif is_hydralette_config(f.type) and not help:\narg_descr = \"Options see below.\"\nelse:\narg_descr = help\n_trace = trace + \".\" if trace else \"\"\ntype_fmt = format_type_info(f.type)\ndefault = \"\"\nif f.default is not DC_MISSING:\ndefault = f\" = {f.default}\"\nelif f.default_factory is not DC_MISSING:\ndf_name = f.default_factory.__name__  # type: ignore\nif df_name == \"&lt;lambda&gt;\":\ndf = inspect.getsource(f.default_factory)\ndf = df[df.find(\"lambda\") :].strip()\nif df == \"lambda: T()\":\ndf = f\"lambda: {f.type.__name__}()\"\nelse:\ndf = f\"{df_name}()\"\ndefault = f\" = {df}\"\narg_name = f\"{_trace}{f.name}: {type_fmt}{default} \"\nprint(f\"\\t{arg_name:70s}{arg_descr}\")\nprinted.append(cls)\nprint()\nsub_config_fields = [field for field in fields(cls) if is_hydralette_config(field.type)]\nfor f in sub_config_fields:\n_trace = trace + \".\" if trace else \"\"\nif f.groups:\nfor key, typ in f.groups.items():\nprint_options_for_class(typ, f\"{_trace}{f.name}\", f\"active if '{f.name}={key}'\")\nelse:\nprint_options_for_class(f.type, f\"{_trace}{f.name}\")\nprint(f\"Usage: python {sys.argv[0]} [option=value]\\n\")\nprint_options_for_class(cls, \"\")\n@classmethod\ndef class_validation(cls):\n\"\"\"Validate that the config class is defined correctly.\n        - Check that group fields have a default that is also a config class.\n        \"\"\"\nfor f in fields(cls):\n# Check that groups have a default config class\nif f.groups and not (isinstance(f.default, type) and issubclass(f.default, ConfigBase)):\nraise HydraletteConfigurationError(\nf\"'{cls.__module__}.{cls.__name__}.{f.name}' is a group\"\n\" but no proper default value is supplied. Pass the default config class (not instance!) \"\n\"as default argument: 'default=YourDefaultConfig'.\"\n)\ndef instance_validation(self):\n\"\"\"Validate that config was correctly instantiated. Checks if\n        - all required args are provided\n        - all validation lambdas pass\n        \"\"\"\nfor f in fields(self):\ncls = self.__class__\nvalue = getattr(self, f.name)\n# Check for missing arguments\nif value is MISSING:\nraise HydraletteConfigurationError(\nf\"'{cls.__module__}.{cls.__name__}' is missing the required argument '{f.name}'\"\n)\nif f.validate is not None and not f.validate(value):\nraise HydraletteConfigurationError(\nf\"Value '{value}' invalid for argument '{f.name}' in '{cls.__module__}.{cls.__name__}'\"\n)\nelif isinstance(value, ConfigBase):\nvalue.instance_validation()\ndef to_dict(self, only_repr=False) -&gt; Dict[str, Any]:\n\"\"\"Convert config to dict. Recursively converts sub-configs to dicts as well.\n        Args:\n            only_repr (bool, optional): If true, all objects of non-builtin types are replaced by their repr. Useful for printing but not for serialization. Defaults to False.\n        Returns:\n            Dict[str, Any]: Converted config\n        \"\"\"\nreturn {field.name: _get_attr(self, field.name, only_repr=only_repr) for field in fields(self)}\ndef to_yaml(self, sort_keys=False, only_repr=False) -&gt; str:\n\"\"\"Convert config to YAML format.\n        Args:\n            sort_keys (bool, optional): If true, keys are sorted alphabetically. Passed to `yaml.dump`. Defaults to False.\n            only_repr (bool, optional): See `to_dict`. Defaults to False.\n        Returns:\n            str: Config in YAML format\n        \"\"\"\nd = self.to_dict(only_repr=only_repr)\nreturn yaml.dump(d, sort_keys=sort_keys)\ndef print_yaml(self):\n\"\"\"Prints the current config in YAML format with `only_repr=True`.\"\"\"\nprint(self.to_yaml(only_repr=True))\ndef resolve_references(self, root_config=None):\n\"\"\"Calls the reference lambdas on all fields.\n        Args:\n            root_config (_type_, optional): _description_. Defaults to None.\n        \"\"\"\nif root_config is None:\nroot_config = self\nfor f in fields(self):  # type: ignore\nvalue = getattr(self, f.name)\nif f.reference is not None:\nsetattr(self, f.name, f.reference(root_config))\nelif is_hydralette_config(value):\nvalue.resolve_references(root_config=root_config)\ndef __getattribute__(self, __name: str) -&gt; Any:\n\"\"\"Default method. Used to silence the static type checker when `from_signature` is used.\n        Args:\n            __name (str): _description_\n        Returns:\n            Any: _description_\n        \"\"\"\nreturn super().__getattribute__(__name)\n</code></pre>"},{"location":"API/#hydralette.ConfigBase.create","title":"<code>create</code>  <code>classmethod</code>","text":"<p>Entry point to instantiate a config.</p> <p>Parameters:</p> Name Type Description Default <code>overrides</code> <code>List[str]</code> <p>Overrides in the format <code>arg.subarg=value</code>. Defaults to <code>sys.argv[1:]</code>.</p> <code>argv[1:]</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>cls</code> is not a subclass of ConfigBase</p> <code>SystemExit</code> <p>After printing the help page</p> <p>Returns:</p> Name Type Description <code>T</code> <code>T</code> <p>Instance of the ConfigClass</p> Source code in <code>hydralette/config.py</code> <pre><code>@classmethod\ndef create(cls: Type[T], overrides: List[str] = sys.argv[1:]) -&gt; T:\n\"\"\"Entry point to instantiate a config.\n    Args:\n        overrides (List[str], optional): Overrides in the format `arg.subarg=value`. Defaults to `sys.argv[1:]`.\n    Raises:\n        ValueError: If `cls` is not a subclass of ConfigBase\n        SystemExit: After printing the help page\n    Returns:\n        T: Instance of the ConfigClass\n    \"\"\"\nif not issubclass(cls, ConfigBase):\nraise ValueError(f\"Type '{cls}' is not a subclass of ConfigBase\")\nfor help_flag in (\"--help\", \"-h\"):\nif help_flag in overrides:\ncls.print_help_page()\nraise SystemExit(0)\nconfig = cls.parse_and_instantiate(overrides)\nconfig.resolve_references()\nconfig.instance_validation()\nreturn config\n</code></pre>"},{"location":"API/#hydralette.ConfigBase.to_dict","title":"<code>to_dict</code>","text":"<p>Convert config to dict. Recursively converts sub-configs to dicts as well.</p> <p>Parameters:</p> Name Type Description Default <code>only_repr</code> <code>bool</code> <p>If true, all objects of non-builtin types are replaced by their repr. Useful for printing but not for serialization. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dict[str, Any]: Converted config</p> Source code in <code>hydralette/config.py</code> <pre><code>def to_dict(self, only_repr=False) -&gt; Dict[str, Any]:\n\"\"\"Convert config to dict. Recursively converts sub-configs to dicts as well.\n    Args:\n        only_repr (bool, optional): If true, all objects of non-builtin types are replaced by their repr. Useful for printing but not for serialization. Defaults to False.\n    Returns:\n        Dict[str, Any]: Converted config\n    \"\"\"\nreturn {field.name: _get_attr(self, field.name, only_repr=only_repr) for field in fields(self)}\n</code></pre>"},{"location":"API/#hydralette.ConfigBase.to_yaml","title":"<code>to_yaml</code>","text":"<p>Convert config to YAML format.</p> <p>Parameters:</p> Name Type Description Default <code>sort_keys</code> <code>bool</code> <p>If true, keys are sorted alphabetically. Passed to <code>yaml.dump</code>. Defaults to False.</p> <code>False</code> <code>only_repr</code> <code>bool</code> <p>See <code>to_dict</code>. Defaults to False.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Config in YAML format</p> Source code in <code>hydralette/config.py</code> <pre><code>def to_yaml(self, sort_keys=False, only_repr=False) -&gt; str:\n\"\"\"Convert config to YAML format.\n    Args:\n        sort_keys (bool, optional): If true, keys are sorted alphabetically. Passed to `yaml.dump`. Defaults to False.\n        only_repr (bool, optional): See `to_dict`. Defaults to False.\n    Returns:\n        str: Config in YAML format\n    \"\"\"\nd = self.to_dict(only_repr=only_repr)\nreturn yaml.dump(d, sort_keys=sort_keys)\n</code></pre>"},{"location":"API/#hydralette.ConfigBase.print_yaml","title":"<code>print_yaml</code>","text":"<p>Prints the current config in YAML format with <code>only_repr=True</code>.</p> Source code in <code>hydralette/config.py</code> <pre><code>def print_yaml(self):\n\"\"\"Prints the current config in YAML format with `only_repr=True`.\"\"\"\nprint(self.to_yaml(only_repr=True))\n</code></pre>"},{"location":"API/#hydralette.ConfigBase.print_help_page","title":"<code>print_help_page</code>  <code>classmethod</code>","text":"<p>Print the help page. Is called automatically by <code>.create()</code> if <code>-h</code> or <code>--help</code> is in the overrides.</p> Source code in <code>hydralette/config.py</code> <pre><code>@classmethod\ndef print_help_page(cls) -&gt; None:\n\"\"\"Print the help page. Is called automatically by `.create()` if `-h` or `--help` is in the overrides.\"\"\"\nprinted = []\ndef format_type_info(t) -&gt; str:\nif get_origin(t) is Union:\nreturn f\"Union[{', '.join(st.__name__ for st in get_args(t))}]\"\nelif hasattr(t, \"__name__\"):\nreturn t.__name__\nelse:\nreturn \"\"\ndef print_options_for_class(cls, trace, group_info=\"\", super_class=None):\nif cls in printed:\nreturn\nif group_info:\ngroup_info = f\" ({group_info})\"\nname = cls.__module__ + \".\" + cls.__name__\nprint(f\"Options from '{name}'{group_info}:\")\nfor f in fields(cls):\nif super_class is not None and f.name in [f.name for f in fields(super_class)]:\ncontinue\nhelp = f.metadata.get(\"help\", \"\")\nif is_hydralette_config(f.type) and help:\narg_descr = f\"Options see below. {help}\"\nelif is_hydralette_config(f.type) and not help:\narg_descr = \"Options see below.\"\nelse:\narg_descr = help\n_trace = trace + \".\" if trace else \"\"\ntype_fmt = format_type_info(f.type)\ndefault = \"\"\nif f.default is not DC_MISSING:\ndefault = f\" = {f.default}\"\nelif f.default_factory is not DC_MISSING:\ndf_name = f.default_factory.__name__  # type: ignore\nif df_name == \"&lt;lambda&gt;\":\ndf = inspect.getsource(f.default_factory)\ndf = df[df.find(\"lambda\") :].strip()\nif df == \"lambda: T()\":\ndf = f\"lambda: {f.type.__name__}()\"\nelse:\ndf = f\"{df_name}()\"\ndefault = f\" = {df}\"\narg_name = f\"{_trace}{f.name}: {type_fmt}{default} \"\nprint(f\"\\t{arg_name:70s}{arg_descr}\")\nprinted.append(cls)\nprint()\nsub_config_fields = [field for field in fields(cls) if is_hydralette_config(field.type)]\nfor f in sub_config_fields:\n_trace = trace + \".\" if trace else \"\"\nif f.groups:\nfor key, typ in f.groups.items():\nprint_options_for_class(typ, f\"{_trace}{f.name}\", f\"active if '{f.name}={key}'\")\nelse:\nprint_options_for_class(f.type, f\"{_trace}{f.name}\")\nprint(f\"Usage: python {sys.argv[0]} [option=value]\\n\")\nprint_options_for_class(cls, \"\")\n</code></pre>"},{"location":"API/#hydralette.HydraletteField","title":"<code>hydralette.HydraletteField</code>","text":"<p>             Bases: <code>Field</code></p> <p>Field subclass that adds</p> <ul> <li>referencing other values</li> <li>type conversion functions</li> <li>validation functions</li> <li>config group information</li> </ul> Source code in <code>hydralette/hydralette_field.py</code> <pre><code>class HydraletteField(Field):\n\"\"\"Field subclass that adds\n    - referencing other values\n    - type conversion functions\n    - validation functions\n    - config group information\n    \"\"\"\ndef __init__(\nself,\n*,\nreference: Optional[Callable] = None,\nconvert: Optional[Callable] = None,\nvalidate: Optional[Callable] = None,\ngroups: Dict[str, type] = {},\n**kwargs,\n):\n\"\"\"HydraletteField constructor\n        Args:\n            reference (Optional[Callable], optional): see `hydralette.field`. Defaults to None.\n            convert (Optional[Callable], optional): see `hydralette.field`. Defaults to None.\n            validate (Optional[Callable], optional): see `hydralette.field`. Defaults to None.\n            groups (Dict[str, type], optional): see `hydralette.field`. Defaults to {}.\n            **kwargs (Any): passed to `dataclasses.Field.__init__`. Defaults to {}\n        \"\"\"\nsuper().__init__(**kwargs)\nself.reference = reference\nself.convert = convert\nself.validate = validate\nself.groups = groups\n@classmethod\ndef from_dc_field(cls: Type[\"HydraletteField\"], field: Field) -&gt; \"HydraletteField\":\n\"\"\"Convert `dataclass.Field` to `HydraletteField`.\n        Args:\n            field (Field): original field\n        Returns:\n            HydraletteField: adapted field\n        \"\"\"\nhydralette_field = cls(\ndefault=field.default,\ndefault_factory=field.default_factory,\ninit=field.init,\nrepr=field.repr,\nhash=field.hash,\ncompare=field.compare,\nmetadata=field.metadata,\nkw_only=field.kw_only,  # type: ignore\n)\nhydralette_field.name = field.name\nhydralette_field.type = field.type  # type: ignore\nhydralette_field._field_type = field._field_type  # type: ignore\nreturn hydralette_field\ndef __repr__(self):\nreturn (\n\"HydraletteField(\"\nf\"name={self.name!r},\"\nf\"type={self.type!r},\"\nf\"default={self.default!r},\"\nf\"default_factory={self.default_factory!r},\"\nf\"init={self.init!r},\"\nf\"repr={self.repr!r},\"\nf\"hash={self.hash!r},\"\nf\"compare={self.compare!r},\"\nf\"metadata={self.metadata!r},\"\nf\"kw_only={self.kw_only!r},\"  # type: ignore\nf\"_field_type={self._field_type},\"  # type: ignore\nf\"reference={self.reference},\"\nf\"convert={self.convert},\"\nf\"validate={self.validate},\"\nf\"groups={self.groups},\"\n\")\"\n)\n@staticmethod\ndef from_signature(callable: Callable, field_kwargs: dict = {}) -&gt; Any:\n\"\"\"Generate field from signature. Called by `hydralette.field` if `from_signature` is not `None`.\n        Args:\n            callable (Callable): _description_\n            field_kwargs (dict, optional): _description_. Defaults to {}.\n        Returns:\n            Any: _description_\n        \"\"\"\nfrom hydralette.config import (  # noqa: avoid circular import\nconfig_from_signature,\n)\nT = config_from_signature(callable)\ndefault_factory = lambda: T()\nT_field = field(default_factory=default_factory, **field_kwargs)\nT_field.type = T\nreturn T_field\n</code></pre>"},{"location":"API/#hydralette.HydraletteField.__init__","title":"<code>__init__</code>","text":"<p>HydraletteField constructor</p> <p>Parameters:</p> Name Type Description Default <code>reference</code> <code>Optional[Callable]</code> <p>see <code>hydralette.field</code>. Defaults to None.</p> <code>None</code> <code>convert</code> <code>Optional[Callable]</code> <p>see <code>hydralette.field</code>. Defaults to None.</p> <code>None</code> <code>validate</code> <code>Optional[Callable]</code> <p>see <code>hydralette.field</code>. Defaults to None.</p> <code>None</code> <code>groups</code> <code>Dict[str, type]</code> <p>see <code>hydralette.field</code>. Defaults to {}.</p> <code>{}</code> <code>**kwargs</code> <code>Any</code> <p>passed to <code>dataclasses.Field.__init__</code>. Defaults to {}</p> <code>{}</code> Source code in <code>hydralette/hydralette_field.py</code> <pre><code>def __init__(\nself,\n*,\nreference: Optional[Callable] = None,\nconvert: Optional[Callable] = None,\nvalidate: Optional[Callable] = None,\ngroups: Dict[str, type] = {},\n**kwargs,\n):\n\"\"\"HydraletteField constructor\n    Args:\n        reference (Optional[Callable], optional): see `hydralette.field`. Defaults to None.\n        convert (Optional[Callable], optional): see `hydralette.field`. Defaults to None.\n        validate (Optional[Callable], optional): see `hydralette.field`. Defaults to None.\n        groups (Dict[str, type], optional): see `hydralette.field`. Defaults to {}.\n        **kwargs (Any): passed to `dataclasses.Field.__init__`. Defaults to {}\n    \"\"\"\nsuper().__init__(**kwargs)\nself.reference = reference\nself.convert = convert\nself.validate = validate\nself.groups = groups\n</code></pre>"},{"location":"API/#hydralette.HydraletteField.from_dc_field","title":"<code>from_dc_field</code>  <code>classmethod</code>","text":"<p>Convert <code>dataclass.Field</code> to <code>HydraletteField</code>.</p> <p>Parameters:</p> Name Type Description Default <code>field</code> <code>Field</code> <p>original field</p> required <p>Returns:</p> Name Type Description <code>HydraletteField</code> <code>HydraletteField</code> <p>adapted field</p> Source code in <code>hydralette/hydralette_field.py</code> <pre><code>@classmethod\ndef from_dc_field(cls: Type[\"HydraletteField\"], field: Field) -&gt; \"HydraletteField\":\n\"\"\"Convert `dataclass.Field` to `HydraletteField`.\n    Args:\n        field (Field): original field\n    Returns:\n        HydraletteField: adapted field\n    \"\"\"\nhydralette_field = cls(\ndefault=field.default,\ndefault_factory=field.default_factory,\ninit=field.init,\nrepr=field.repr,\nhash=field.hash,\ncompare=field.compare,\nmetadata=field.metadata,\nkw_only=field.kw_only,  # type: ignore\n)\nhydralette_field.name = field.name\nhydralette_field.type = field.type  # type: ignore\nhydralette_field._field_type = field._field_type  # type: ignore\nreturn hydralette_field\n</code></pre>"},{"location":"API/#hydralette.field","title":"<code>hydralette.field</code>","text":"<p>Function to create <code>HydraletteField</code>s. Like <code>dataclasses.field</code> with additional features.</p> <p>Parameters:</p> Name Type Description Default <code>reference</code> <code>Optional[Callable]</code> <p>Reference lambda that gets the root config and returns a value for this field. Defaults to None.</p> <code>None</code> <code>convert</code> <code>Optional[Callable]</code> <p>Conversion lambda that gets the value passed via CLI and returns a value for this field. Defaults to None.</p> <code>None</code> <code>validate</code> <code>Optional[Callable]</code> <p>Validation lambda that gets the value of this field and returns true if the value is valid. Defaults to None.</p> <code>None</code> <code>groups</code> <code>Dict[str, type]</code> <p>Group definition, allows switching the config class of a sub-config field via cli. Defaults to {}.</p> <code>{}</code> <code>from_signature</code> <code>Optional[Callable]</code> <p>Use the signature of an arbitrary callable as the config class for this field. Defaults to None.</p> <code>None</code> <code>default</code> <code>_type_</code> <p>passed to <code>dataclasses.Field</code>. Defaults to MISSING.</p> <code>MISSING</code> <code>default_factory</code> <code>_type_</code> <p>passed to <code>dataclasses.Field</code>. Defaults to MISSING.</p> <code>MISSING</code> <code>init</code> <code>bool</code> <p>passed to <code>dataclasses.Field</code>. Defaults to True.</p> <code>True</code> <code>repr</code> <code>bool</code> <p>passed to <code>dataclasses.Field</code>. Defaults to True.</p> <code>True</code> <code>hash</code> <code>_type_</code> <p>passed to <code>dataclasses.Field</code>. Defaults to None.</p> <code>None</code> <code>compare</code> <code>bool</code> <p>passed to <code>dataclasses.Field</code>. Defaults to True.</p> <code>True</code> <code>metadata</code> <code>_type_</code> <p>passed to <code>dataclasses.Field</code>. Defaults to None.</p> <code>None</code> <code>kw_only</code> <code>_type_</code> <p>passed to <code>dataclasses.Field</code>. Defaults to MISSING.</p> <code>MISSING</code> <p>Returns:</p> Name Type Description <code>field</code> <code>HydraletteField</code> <p>Instantiated field</p> Source code in <code>hydralette/hydralette_field.py</code> <pre><code>def field(\n*,\nreference: Optional[Callable] = None,\nconvert: Optional[Callable] = None,\nvalidate: Optional[Callable] = None,\ngroups: Dict[str, type] = {},\nfrom_signature: Optional[Callable] = None,\ndefault=MISSING,\ndefault_factory=MISSING,\ninit=True,\nrepr=True,\nhash=None,\ncompare=True,\nmetadata=None,\nkw_only=MISSING,\n) -&gt; Any:\n\"\"\"Function to create `HydraletteField`s. Like `dataclasses.field` with additional features.\n    Args:\n        reference (Optional[Callable], optional): Reference lambda that gets the root config and returns a value for this field. Defaults to None.\n        convert (Optional[Callable], optional): Conversion lambda that gets the value passed via CLI and returns a value for this field. Defaults to None.\n        validate (Optional[Callable], optional): Validation lambda that gets the value of this field and returns true if the value is valid. Defaults to None.\n        groups (Dict[str, type], optional): Group definition, allows switching the config class of a sub-config field via cli. Defaults to {}.\n        from_signature (Optional[Callable], optional): Use the signature of an arbitrary callable as the config class for this field. Defaults to None.\n        default (_type_, optional): passed to `dataclasses.Field`. Defaults to MISSING.\n        default_factory (_type_, optional): passed to `dataclasses.Field`. Defaults to MISSING.\n        init (bool, optional): passed to `dataclasses.Field`. Defaults to True.\n        repr (bool, optional): passed to `dataclasses.Field`. Defaults to True.\n        hash (_type_, optional): passed to `dataclasses.Field`. Defaults to None.\n        compare (bool, optional): passed to `dataclasses.Field`. Defaults to True.\n        metadata (_type_, optional): passed to `dataclasses.Field`. Defaults to None.\n        kw_only (_type_, optional): passed to `dataclasses.Field`. Defaults to MISSING.\n    Returns:\n        field (HydraletteField): Instantiated field\n    \"\"\"\nif from_signature is not None:\nif default_factory is not MISSING:\nlog.warn(\"'from_signature' and 'default_factory' are not compatible.\")\nif default is not MISSING:\nlog.warn(\"'from_signature' and 'default' are not compatible.\")\nreturn HydraletteField.from_signature(\nfrom_signature,\nfield_kwargs=dict(\nreference=reference,\nconvert=convert,\nvalidate=validate,\ngroups=groups,\ninit=init,\nrepr=repr,\nhash=hash,\ncompare=compare,\nmetadata=metadata,\nkw_only=kw_only,\n),\n)\nif reference is not None and default is MISSING and default_factory is MISSING:\n# Avoid error from dataclasses that non-default arguments cannot follow default arguments\n# default value is irrelevant anyway, since the value will be determined by the reference lambda\ndefault = None\nreturn HydraletteField(\nreference=reference,\nconvert=convert,\nvalidate=validate,\ngroups=groups,\ndefault=default,\ndefault_factory=default_factory,\ninit=init,\nrepr=repr,\nhash=hash,\ncompare=compare,\nmetadata=metadata,\nkw_only=kw_only,\n)\n</code></pre>"},{"location":"API/#hydralette.fields","title":"<code>hydralette.fields</code>","text":"<p>Wrapper around <code>dataclasses.fields</code> to change type hint to <code>Tuple[HydraletteField]</code>.</p> <p>Parameters:</p> Name Type Description Default <code>class_or_instance</code> <code>_type_</code> <p>description</p> required <p>Returns:</p> Type Description <code>Tuple[HydraletteField]</code> <p>Tuple[HydraletteField]: description</p> Source code in <code>hydralette/hydralette_field.py</code> <pre><code>def fields(class_or_instance) -&gt; Tuple[HydraletteField]:\n\"\"\"Wrapper around `dataclasses.fields` to change type hint to `Tuple[HydraletteField]`.\n    Args:\n        class_or_instance (_type_): _description_\n    Returns:\n        Tuple[HydraletteField]: _description_\n    \"\"\"\nreturn dc_fields(class_or_instance)  # type: ignore\n</code></pre>"},{"location":"API/#hydralette.config_from_signature","title":"<code>hydralette.config_from_signature(callable)</code>","text":"<p>Generate a config from an arbitrary signature.</p> <p>Parameters:</p> Name Type Description Default <code>callable</code> <code>Callable</code> <p>Callable to get the signature from</p> required <p>Returns:</p> Type Description <code>Type[ConfigBase]</code> <p>Type[ConfigBase]: Config Class</p> Source code in <code>hydralette/config.py</code> <pre><code>def config_from_signature(callable: Callable) -&gt; Type[ConfigBase]:\n\"\"\"Generate a config from an arbitrary signature.\n    Args:\n        callable (Callable): Callable to get the signature from\n    Returns:\n        Type[ConfigBase]: Config Class\n    \"\"\"\nannotations = {\nparameter.name: parameter._annotation if parameter._annotation is not inspect._empty else Any\nfor parameter in inspect.signature(callable)._parameters.values()  # type: ignore\n}\ndunders = {\"__annotations__\": annotations}\nif hasattr(callable, \"__module__\"):\ndunders[\"__module__\"] = callable.__module__  # type: ignore\nfields = {\nparameter.name: field(default=parameter.default if parameter.default is not inspect._empty else MISSING)\nfor parameter in inspect.signature(callable)._parameters.values()  # type: ignore\n}\nT = type(f\"{callable.__name__}Hydralette\", (ConfigBase,), {**dunders, **fields})\nreturn T\n</code></pre>"},{"location":"API/#hydralette.is_hydralette_config","title":"<code>hydralette.is_hydralette_config(obj)</code>","text":"<p>Helper function to check if something is a hydralette config. Returns true if</p> <ul> <li><code>obj</code> is an instance of <code>ConfigBase</code> or</li> <li><code>obj</code> is a subclass of <code>ConfigBase</code> or</li> <li><code>obj</code> is a <code>typing.Union</code> of subclasses of <code>ConfigBase</code></li> </ul> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>Any</code> <p>description</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>description</p> Source code in <code>hydralette/config.py</code> <pre><code>def is_hydralette_config(obj: Any) -&gt; bool:\n\"\"\"Helper function to check if something is a hydralette config. Returns true if\n    - `obj` is an instance of `ConfigBase` or\n    - `obj` is a subclass of `ConfigBase` or\n    - `obj` is a `typing.Union` of subclasses of `ConfigBase`\n    Args:\n        obj (Any): _description_\n    Returns:\n        bool: _description_\n    \"\"\"\nreturn (\nisinstance(obj, ConfigBase)\nor (isinstance(obj, type) and issubclass(obj, ConfigBase))\nor (get_origin(obj) is Union and all(issubclass(t, ConfigBase) for t in get_args(obj)))\n)\n</code></pre>"},{"location":"API/#hydralette.HydraletteConfigurationError","title":"<code>hydralette.HydraletteConfigurationError</code>","text":"<p>             Bases: <code>Exception</code></p> <p>General Hydralette Exception class</p> Source code in <code>hydralette/exceptions.py</code> <pre><code>class HydraletteConfigurationError(Exception):\n\"\"\"General Hydralette Exception class\"\"\"\npass\n</code></pre>"},{"location":"API/#hydralette.MISSING","title":"<code>hydralette.MISSING = MISSING_TYPE()</code>  <code>module-attribute</code>","text":"<p>Flag to indicate that a field is required.</p>"},{"location":"examples/","title":"Examples","text":""},{"location":"examples/#minimal-example","title":"Minimal Example","text":"<p>Hydralette configs are defined similar to dataclasses. Instead of decorating your class with <code>@dataclass</code>, derive it from <code>ConfigBase</code>.</p> <pre><code>from hydralette import ConfigBase, field, MISSING\nclass ModelConfig(ConfigBase):\nn_layers: int = field(\ndefault=32,\nmetadata=dict(help=\"Number of Layers\")\n)\ndropout: float = field(\ndefault=0.1,\nmetadata=dict(help=\"Dropout p value\")\n)\nif __name__ == \"__main__\":\nconfig = ModelConfig.create()\n</code></pre>"},{"location":"examples/#hierarchical-configs","title":"Hierarchical Configs","text":"<p>Note</p> <p>Complete example in examples/01_getting_started.py</p> <pre><code>class ModelConfig(ConfigBase):\nn_layers: int = field(\ndefault=32,\nmetadata=dict(help=\"Number of Layers\")\n)\ndropout: float = field(\ndefault=0.1,\nmetadata=dict(help=\"Dropout p value\")\n)\nclass Config(ConfigBase):\noutput_dir: Path = field(\ndefault=Path(\"output\"),\nmetadata=dict(help=\"Ouput directory to save all results to\")\n)\nmodel: ModelConfig = field(  # &lt;-- specify another config class as field type to make the config hierarchical\ndefault_factory=lambda: ModelConfig(),\nmetadata=dict(help=\"Config for model\")\n)\n</code></pre>"},{"location":"examples/#from-signature","title":"From Signature","text":"<p>Note</p> <p>Complete example in examples/06_from_signature.py</p> <p>Warning</p> <p>Static analysis and auto-complete does not work with dynamically generated config classes.</p> <p>If you already have an interface defined in the signature of a class or function, you can directly create your config from that without the need for duplicate code.</p> <pre><code>class Config(ConfigBase):\nmyclass = field(\nfrom_signature=MyClass,  # &lt;-- generate config class from constructor signature and use as field\nmetadata=dict(help=\"This is helpful text\"),\n)\nmy_func = field(from_signature=my_func)  # &lt;-- generate config class from function signature and use as field\n</code></pre>"},{"location":"examples/#cli","title":"CLI","text":"<p>All config fields can be overriden via the CLI. To make a field mandatory set its default to <code>hydralette.MISSING</code>.</p> <pre><code>from hydralette import ConfigBase, field, MISSING\nclass ModelConfig(ConfigBase):\nn_layers: int = field(\ndefault=32,\nmetadata=dict(help=\"Number of Layers\")\n)\ndropout: float = field(\ndefault=MISSING,     # &lt;-- required argument\nmetadata=dict(help=\"Dropout p value\")\n)\nclass Config(ConfigBase):\noutput_dir: Path = field(\ndefault=Path(\"output\"),\nmetadata=dict(help=\"Ouput directory to save all results to\")\n)\nmodel: ModelConfig = field(\ndefault_factory=lambda: ModelConfig(),\nmetadata=dict(help=\"Config for model\")\n)\nif __name__ == \"__main__\":\nconfig = Config.create()\n</code></pre> <pre><code>$ python example.py -h\nUsage: python test.py [option=value]\nOptions from '__main__.Config':\n        output_dir: Path                                       Ouput directory to save all results to\n        model: ModelConfig                                     Options see below\n\nOptions from '__main__.ModelConfig':\n        model.n_layers: int                                    Number of Layers\n        model.dropout: float                                   Dropout p value\n</code></pre>"},{"location":"examples/#config-groups","title":"Config Groups","text":"<p>Note</p> <p>Complete example in examples/02_groups.py</p> <p>When configuring heterogeneous applications with interchangable parts, shared configurations can get messy. Different components might fulfill the same purpose but still require very different configuration paramters. Hydralette supports config groups to disentangle such configs. Components can then swapped with a single CLI override.</p> <pre><code>class TransformerModelConfig(ConfigBase):\nn_layers: int = field(\ndefault=32,\nmetadata=dict(help=\"Number of Transformer Layers\")\n)\nnum_attention_heads: int = field(\ndefault=8,\nmetadata=dict(help=\"Number of Attention Heads per Layer\")\n)\nclass RNNModelConfig(ConfigBase):\nn_layers: int = field(\ndefault=4,\nmetadata=dict(help=\"Number of RNN Layers\")\n)\nbidirectional: bool = field(\ndefault=True,\nmetadata=dict(help=\"Bidirectional or Unidirectional RNN Layers\")\n)\nclass Config(ConfigBase):\noutput_dir: Path = field(\ndefault=Path(\"output\"),\nmetadata=dict(help=\"Ouput directory to save all results to\")\n)\nmodel: Union[TransformerModelConfig, RNNModelConfig] = field(\ndefault=RNNModelConfig,                                              # &lt;-- default config class\nmetadata=dict(help=\"Config for model\"),\ngroups=dict(transformer=TransformerModelConfig, rnn=RNNModelConfig), # &lt;-- &lt;key&gt;=&lt;config class&gt;\n)\nif __name__ == \"__main__\":\nconfig = Config.create()\nconfig.print_yaml()\n</code></pre> <pre><code>$ python test.py model=transformer\n\noutput_dir: PosixPath('output')\nmodel:\n  n_layers: 32\nnum_attention_heads: 8\n</code></pre>"},{"location":"examples/#compatibility-with-pure-dataclasses","title":"Compatibility with pure dataclasses","text":"<p>Note</p> <p>Complete example in examples/03_existing_dataclass.py</p> <p>Some libraries define their configuration as dataclasses. To use an existing dataclass as hydralette config, simply derive from it and <code>ConfigBase</code>.</p> <pre><code>from library import LibraryConfig\nclass MyConfig(LibraryConfig, ConfigBase):\npass\n</code></pre>"},{"location":"examples/#references","title":"References","text":"<p>Note</p> <p>Complete example in examples/04_references.py</p> <p>Sometimes a configuration value is required by multiple components. To avoid defining and overriding it in multiple places, simply reference a single source of truth. The <code>reference</code> API works with functions that take the main config as input and output and arbitrary value, so you can add things and combine multiple other values.</p> <pre><code>class Config(ConfigBase):\noutput_dir: Path = field(\ndefault=Path(\"output\"),\nmetadata=dict(help=\"Output directory to save all results to\")\n)\nrun_name: str = field(\ndefault=\"run-001\",\nmetadata=dict(help=\"Name of the run\")\n)\ncheckpoint_dir: Path = field(\nreference=lambda cfg: cfg.output_dir / cfg.run_name / \"checkpoints\"\n)\n</code></pre>"},{"location":"examples/#type-conversion","title":"Type Conversion","text":"<p>Values from the CLI need to converted to their correct type. If the type annotation already works as converter, types will be automatically converted. Alternatively, you can also provide a conversion function via <code>convert</code>.</p> <pre><code>class Config(ConfigBase):\noutput_dir: Path = field(\ndefault=Path(\"~/output\").expanduser(),\nmetadata=dict(help=\"Output directory to save all results to\"),\nconvert=lambda value: Path(value).expanduser()      # custom type conversion to add expanduser\n)\n</code></pre>"},{"location":"examples/#validation","title":"Validation","text":"<p>Every field can be validated by passing a lambda with signature <code>(value) -&gt; (bool)</code> to <code>validate</code>.</p> <pre><code>class Config(ConfigBase):\nn_layers: int = field(\ndefault=32,\nmetadata=dict(help=\"Number of Layers\"),\nvalidate=lambda value: value &gt; 0\n)\n</code></pre>"}]}